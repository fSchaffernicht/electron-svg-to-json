{"ast":null,"code":"/* global a2c */\n'use strict';\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n    regPathData = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)([eE][-+]?\\d+)?/g,\n    regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n    transform2js = require('./_transforms').transform2js,\n    transformsMultiply = require('./_transforms').transformsMultiply,\n    transformArc = require('./_transforms').transformArc,\n    collections = require('./_collections.js'),\n    referencesProps = collections.referencesProps,\n    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n    prevCtrlPoint;\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\n\nexports.path2js = function (path) {\n  if (path.pathJS) return path.pathJS;\n  var paramsLength = {\n    // Number of parameters of every path command\n    H: 1,\n    V: 1,\n    M: 2,\n    L: 2,\n    T: 2,\n    Q: 4,\n    S: 4,\n    C: 6,\n    A: 7,\n    h: 1,\n    v: 1,\n    m: 2,\n    l: 2,\n    t: 2,\n    q: 4,\n    s: 4,\n    c: 6,\n    a: 7\n  },\n      pathData = [],\n      // JS representation of the path data\n  instruction,\n      // current instruction context\n  startMoveto = false; // splitting path string into array like ['M', '10 50', 'L', '20 30']\n\n  path.attr('d').value.split(regPathInstructions).forEach(function (data) {\n    if (!data) return;\n\n    if (!startMoveto) {\n      if (data == 'M' || data == 'm') {\n        startMoveto = true;\n      } else return;\n    } // instruction item\n\n\n    if (regPathInstructions.test(data)) {\n      instruction = data; // z - instruction w/o data\n\n      if (instruction == 'Z' || instruction == 'z') {\n        pathData.push({\n          instruction: 'z'\n        });\n      } // data item\n\n    } else {\n      data = data.match(regPathData);\n      if (!data) return;\n      data = data.map(Number); // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n      // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n\n      if (instruction == 'M' || instruction == 'm') {\n        pathData.push({\n          instruction: pathData.length == 0 ? 'M' : instruction,\n          data: data.splice(0, 2)\n        });\n        instruction = instruction == 'M' ? 'L' : 'l';\n      }\n\n      for (var pair = paramsLength[instruction]; data.length;) {\n        pathData.push({\n          instruction: instruction,\n          data: data.splice(0, pair)\n        });\n      }\n    }\n  }); // First moveto is actually absolute. Subsequent coordinates were separated above.\n\n  if (pathData.length && pathData[0].instruction == 'm') {\n    pathData[0].instruction = 'M';\n  }\n\n  path.pathJS = pathData;\n  return pathData;\n};\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\n\n\nvar relative2absolute = exports.relative2absolute = function (data) {\n  var currentPoint = [0, 0],\n      subpathPoint = [0, 0],\n      i;\n  data = data.map(function (item) {\n    var instruction = item.instruction,\n        itemData = item.data && item.data.slice();\n\n    if (instruction == 'M') {\n      set(currentPoint, itemData);\n      set(subpathPoint, itemData);\n    } else if ('mlcsqt'.indexOf(instruction) > -1) {\n      for (i = 0; i < itemData.length; i++) {\n        itemData[i] += currentPoint[i % 2];\n      }\n\n      set(currentPoint, itemData);\n\n      if (instruction == 'm') {\n        set(subpathPoint, itemData);\n      }\n    } else if (instruction == 'a') {\n      itemData[5] += currentPoint[0];\n      itemData[6] += currentPoint[1];\n      set(currentPoint, itemData);\n    } else if (instruction == 'h') {\n      itemData[0] += currentPoint[0];\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'v') {\n      itemData[0] += currentPoint[1];\n      currentPoint[1] = itemData[0];\n    } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n      set(currentPoint, itemData);\n    } else if (instruction == 'H') {\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'V') {\n      currentPoint[1] = itemData[0];\n    } else if (instruction == 'z') {\n      set(currentPoint, subpathPoint);\n    }\n\n    return instruction == 'z' ? {\n      instruction: 'z'\n    } : {\n      instruction: instruction.toUpperCase(),\n      data: itemData\n    };\n  });\n  return data;\n};\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\n\n\nexports.applyTransforms = function (elem, path, params) {\n  // if there are no 'stroke' attr and references to other objects such as\n  // gradiends or clip-path which are also subjects to transform.\n  if (!elem.hasAttr('transform') || !elem.attr('transform').value || elem.someAttr(function (attr) {\n    return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n  })) return path;\n  var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n      stroke = elem.computedAttr('stroke'),\n      id = elem.computedAttr('id'),\n      transformPrecision = params.transformPrecision,\n      newPoint,\n      scale;\n\n  if (stroke && stroke != 'none') {\n    if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2])) return path; // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n\n    if (id) {\n      var idElem = elem,\n          hasStrokeWidth = false;\n\n      do {\n        if (idElem.hasAttr('stroke-width')) hasStrokeWidth = true;\n      } while (!idElem.hasAttr('id', id) && !hasStrokeWidth && (idElem = idElem.parentNode));\n\n      if (!hasStrokeWidth) return path;\n    }\n\n    scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n    if (scale !== 1) {\n      var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n      if (elem.hasAttr('stroke-width')) {\n        elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim().replace(regNumericValues, function (num) {\n          return removeLeadingZero(num * scale);\n        });\n      } else {\n        elem.addAttr({\n          name: 'stroke-width',\n          prefix: '',\n          local: 'stroke-width',\n          value: strokeWidth.replace(regNumericValues, function (num) {\n            return removeLeadingZero(num * scale);\n          })\n        });\n      }\n    }\n  } else if (id) {\n    // Stroke and stroke-width can be redefined with <use>\n    return path;\n  }\n\n  path.forEach(function (pathItem) {\n    if (pathItem.data) {\n      // h -> l\n      if (pathItem.instruction === 'h') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = 0; // v -> l\n      } else if (pathItem.instruction === 'v') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = pathItem.data[0];\n        pathItem.data[0] = 0;\n      } // if there is a translate() transform\n\n\n      if (pathItem.instruction === 'M' && (matrix.data[4] !== 0 || matrix.data[5] !== 0)) {\n        // then apply it only to the first absoluted M\n        newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n        set(pathItem.data, newPoint);\n        set(pathItem.coords, newPoint); // clear translate() data from transform matrix\n\n        matrix.data[4] = 0;\n        matrix.data[5] = 0;\n      } else {\n        if (pathItem.instruction == 'a') {\n          transformArc(pathItem.data, matrix.data); // reduce number of digits in rotation angle\n\n          if (Math.abs(pathItem.data[2]) > 80) {\n            var a = pathItem.data[0],\n                rotation = pathItem.data[2];\n            pathItem.data[0] = pathItem.data[1];\n            pathItem.data[1] = a;\n            pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n          }\n\n          newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n          pathItem.data[5] = newPoint[0];\n          pathItem.data[6] = newPoint[1];\n        } else {\n          for (var i = 0; i < pathItem.data.length; i += 2) {\n            newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n            pathItem.data[i] = newPoint[0];\n            pathItem.data[i + 1] = newPoint[1];\n          }\n        }\n\n        pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n        pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n      }\n    }\n  }); // remove transform attr\n\n  elem.removeAttr('transform');\n  return path;\n};\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\n\n\nfunction transformPoint(matrix, x, y) {\n  return [matrix[0] * x + matrix[2] * y + matrix[4], matrix[1] * x + matrix[3] * y + matrix[5]];\n}\n/**\n * Compute Cubic BÃ©zie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\n\n\nexports.computeCubicBoundingBox = function (xa, ya, xb, yb, xc, yc, xd, yd) {\n  var minx = Number.POSITIVE_INFINITY,\n      miny = Number.POSITIVE_INFINITY,\n      maxx = Number.NEGATIVE_INFINITY,\n      maxy = Number.NEGATIVE_INFINITY,\n      ts,\n      t,\n      x,\n      y,\n      i; // X\n\n  if (xa < minx) {\n    minx = xa;\n  }\n\n  if (xa > maxx) {\n    maxx = xa;\n  }\n\n  if (xd < minx) {\n    minx = xd;\n  }\n\n  if (xd > maxx) {\n    maxx = xd;\n  }\n\n  ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n\n    if (t >= 0 && t <= 1) {\n      x = computeCubicBaseValue(t, xa, xb, xc, xd); // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (x < minx) {\n        minx = x;\n      }\n\n      if (x > maxx) {\n        maxx = x;\n      }\n    }\n  } // Y\n\n\n  if (ya < miny) {\n    miny = ya;\n  }\n\n  if (ya > maxy) {\n    maxy = ya;\n  }\n\n  if (yd < miny) {\n    miny = yd;\n  }\n\n  if (yd > maxy) {\n    maxy = yd;\n  }\n\n  ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n\n    if (t >= 0 && t <= 1) {\n      // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n      y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (y < miny) {\n        miny = y;\n      }\n\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n  }\n\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n}; // compute the value for the cubic bezier function at time=t\n\n\nfunction computeCubicBaseValue(t, a, b, c, d) {\n  var mt = 1 - t;\n  return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n} // compute the value for the first derivative of the cubic bezier function at time=t\n\n\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n  var result = [-1, -1],\n      tl = -a + 2 * b - c,\n      tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n      dn = -a + 3 * b - 3 * c + d;\n\n  if (dn !== 0) {\n    result[0] = (tl + tr) / dn;\n    result[1] = (tl - tr) / dn;\n  }\n\n  return result;\n}\n/**\n * Compute Quadratic BÃ©zier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\n\n\nexports.computeQuadraticBoundingBox = function (xa, ya, xb, yb, xc, yc) {\n  var minx = Number.POSITIVE_INFINITY,\n      miny = Number.POSITIVE_INFINITY,\n      maxx = Number.NEGATIVE_INFINITY,\n      maxy = Number.NEGATIVE_INFINITY,\n      t,\n      x,\n      y; // X\n\n  if (xa < minx) {\n    minx = xa;\n  }\n\n  if (xa > maxx) {\n    maxx = xa;\n  }\n\n  if (xc < minx) {\n    minx = xc;\n  }\n\n  if (xc > maxx) {\n    maxx = xc;\n  }\n\n  t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n\n  if (t >= 0 && t <= 1) {\n    x = computeQuadraticBaseValue(t, xa, xb, xc); // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (x < minx) {\n      minx = x;\n    }\n\n    if (x > maxx) {\n      maxx = x;\n    }\n  } // Y\n\n\n  if (ya < miny) {\n    miny = ya;\n  }\n\n  if (ya > maxy) {\n    maxy = ya;\n  }\n\n  if (yc < miny) {\n    miny = yc;\n  }\n\n  if (yc > maxy) {\n    maxy = yc;\n  }\n\n  t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n\n  if (t >= 0 && t <= 1) {\n    // x = computeQuadraticBaseValue(t, xa, xb, xc);\n    y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (y < miny) {\n      miny = y;\n    }\n\n    if (y > maxy) {\n      maxy = y;\n    }\n  }\n\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n}; // compute the value for the quadratic bezier function at time=t\n\n\nfunction computeQuadraticBaseValue(t, a, b, c) {\n  var mt = 1 - t;\n  return mt * mt * a + 2 * mt * t * b + t * t * c;\n} // compute the value for the first derivative of the quadratic bezier function at time=t\n\n\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n  var t = -1,\n      denominator = a - 2 * b + c;\n\n  if (denominator !== 0) {\n    t = (a - b) / denominator;\n  }\n\n  return t;\n}\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\n\n\nexports.js2path = function (path, data, params) {\n  path.pathJS = data;\n\n  if (params.collapseRepeated) {\n    data = collapseRepeated(data);\n  }\n\n  path.attr('d').value = data.reduce(function (pathString, item) {\n    return pathString += item.instruction + (item.data ? cleanupOutData(item.data, params) : '');\n  }, '');\n};\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\n\n\nfunction collapseRepeated(data) {\n  var prev, prevIndex; // copy an array and modifieds item to keep original data untouched\n\n  data = data.reduce(function (newPath, item) {\n    if (prev && item.data && item.instruction == prev.instruction) {\n      // concat previous data with current\n      if (item.instruction != 'M') {\n        prev = newPath[prevIndex] = {\n          instruction: prev.instruction,\n          data: prev.data.concat(item.data),\n          coords: item.coords,\n          base: prev.base\n        };\n      } else {\n        prev.data = item.data;\n        prev.coords = item.coords;\n      }\n    } else {\n      newPath.push(item);\n      prev = item;\n      prevIndex = newPath.length - 1;\n    }\n\n    return newPath;\n  }, []);\n  return data;\n}\n\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\n\n\nexports.intersects = function (path1, path2) {\n  if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n  // Collect points of every subpath.\n\n  var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n      points2 = relative2absolute(path2).reduce(gatherPoints, []); // Axis-aligned bounding box check.\n\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.every(function (set1) {\n    return points2.every(function (set2) {\n      return set1[set1.maxX][0] <= set2[set2.minX][0] || set2[set2.maxX][0] <= set1[set1.minX][0] || set1[set1.maxY][1] <= set2[set2.minY][1] || set2[set2.maxY][1] <= set1[set1.minY][1];\n    });\n  })) return false; // Get a convex hull from points of each subpath. Has the most complexity O(nÂ·log n).\n\n  var hullNest1 = points1.map(convexHull),\n      hullNest2 = points2.map(convexHull); // Check intersection of every subpath of the first path with every subpath of the second.\n\n  return hullNest1.some(function (hull1) {\n    if (hull1.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n          // create the initial simplex\n      direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n\n      while (true) {\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means âdo nothing with pathsâ\n        } // add a new point\n\n\n        simplex.push(getSupport(hull1, hull2, direction)); // see if the new point was on the correct side of the origin\n\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false; // process the simplex\n\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  } // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n\n\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n        max = -Infinity,\n        value;\n\n    while ((value = dot(polygon[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.length;\n    }\n\n    return polygon[(index || polygon.length) - 1];\n  }\n};\n\nfunction processSimplex(simplex, direction) {\n  /* jshint -W004 */\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    var a = simplex[1],\n        b = simplex[0],\n        AO = minus(simplex[1]),\n        AB = sub(b, a); // AO is in the same direction as AB\n\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO); // only A remains in the simplex\n\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    var a = simplex[2],\n        // [a, b, c] = simplex\n    b = simplex[1],\n        c = simplex[0],\n        AB = sub(b, a),\n        AC = sub(c, a),\n        AO = minus(a),\n        ACB = orth(AB, AC),\n        // the vector perpendicular to AB facing away from C\n    ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else // region 7\n      return true;\n  }\n\n  return false;\n}\n\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\nfunction gatherPoints(points, item, index, path) {\n  var subPath = points.length && points[points.length - 1],\n      prev = index && path[index - 1],\n      basePoint = subPath.length && subPath[subPath.length - 1],\n      data = item.data,\n      ctrlPoint = basePoint;\n\n  switch (item.instruction) {\n    case 'M':\n      points.push(subPath = []);\n      break;\n\n    case 'H':\n      addPoint(subPath, [data[0], basePoint[1]]);\n      break;\n\n    case 'V':\n      addPoint(subPath, [basePoint[0], data[0]]);\n      break;\n\n    case 'Q':\n      addPoint(subPath, data.slice(0, 2));\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n\n      break;\n\n    case 'T':\n      if (prev.instruction == 'Q' && prev.instruction == 'T') {\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        addPoint(subPath, ctrlPoint);\n        prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n      }\n\n      break;\n\n    case 'C':\n      // Approximate quibic Bezier curve with middle points between control points\n      addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n      prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n\n      break;\n\n    case 'S':\n      if (prev.instruction == 'C' && prev.instruction == 'S') {\n        addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n      }\n\n      addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n      break;\n\n    case 'A':\n      // Convert the arc to bezier curves and use the same approximation\n      var curves = a2c.apply(0, basePoint.concat(data));\n\n      for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n        addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n        addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n        addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n        if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n      }\n\n      break;\n  } // Save final command coordinates\n\n\n  if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n  return points;\n\n  function toAbsolute(n, i) {\n    return n + basePoint[i % 2];\n  } // Writes data about the extreme points on each axle\n\n\n  function addPoint(path, point) {\n    if (!path.length || point[1] > path[path.maxY][1]) {\n      path.maxY = path.length;\n      points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n\n    if (!path.length || point[0] > path[path.maxX][0]) {\n      path.maxX = path.length;\n      points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n\n    if (!path.length || point[1] < path[path.minY][1]) {\n      path.minY = path.length;\n      points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n    }\n\n    if (!path.length || point[0] < path[path.minX][0]) {\n      path.minX = path.length;\n      points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n    }\n\n    path.push(point);\n  }\n}\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\n\n\nfunction convexHull(points) {\n  /* jshint -W004 */\n  points.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n      minY = 0,\n      bottom = 0;\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    if (points[i][1] < points[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n\n    lower.push(points[i]);\n  }\n\n  var upper = [],\n      maxY = points.length - 1,\n      top = 0;\n\n  for (var i = points.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    if (points[i][1] > points[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n\n    upper.push(points[i]);\n  } // last points are equal to starting points of the other part\n\n\n  upper.pop();\n  lower.pop();\n  var hull = lower.concat(upper);\n  hull.minX = 0; // by sorting\n\n  hull.maxX = lower.length;\n  hull.minY = bottom;\n  hull.maxY = (lower.length + top) % hull.length;\n  return hull;\n}\n\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n// jshint ignore: start\n\n\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  var _120 = Math.PI * 120 / 180,\n      rad = Math.PI / 180 * (+angle || 0),\n      res = [],\n      rotateX = function rotateX(x, y, rad) {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  },\n      rotateY = function rotateY(x, y, rad) {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n        y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx,\n        ry2 = ry * ry,\n        k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n        cx = k * rx * y / ry + (x1 + x2) / 2,\n        cy = k * -ry * x / rx + (y1 + y2) / 2,\n        f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n        f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n        x2old = x2,\n        y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n      s1 = Math.sin(f1),\n      c2 = Math.cos(f2),\n      s2 = Math.sin(f2),\n      t = Math.tan(df / 4),\n      hx = 4 / 3 * rx * t,\n      hy = 4 / 3 * ry * t,\n      m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n\n    return newres;\n  }\n} // jshint ignore: end","map":null,"metadata":{},"sourceType":"script"}