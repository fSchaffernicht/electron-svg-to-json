{"ast":null,"code":"/* jshint quotmark: false */\n'use strict';\n\nexports.type = 'perItem';\nexports.active = true;\nexports.description = 'converts style to attributes';\n\nvar EXTEND = require('whet.extend'),\n    stylingProps = require('./_collections').attrsGroups.presentation,\n    rEscape = '\\\\\\\\(?:[0-9a-f]{1,6}\\\\s?|\\\\r\\\\n|.)',\n    // Like \\\" or \\2051. Code points consume one space.\nrAttr = '\\\\s*(' + g('[^:;\\\\\\\\]', rEscape) + '*?)\\\\s*',\n    // attribute name like ‘fill’\nrSingleQuotes = \"'(?:[^'\\\\n\\\\r\\\\\\\\]|\" + rEscape + \")*?(?:'|$)\",\n    // string in single quotes: 'smth'\nrQuotes = '\"(?:[^\"\\\\n\\\\r\\\\\\\\]|' + rEscape + ')*?(?:\"|$)',\n    // string in double quotes: \"smth\"\nrQuotedString = new RegExp('^' + g(rSingleQuotes, rQuotes) + '$'),\n    // Parentheses, E.g.: url(data:image/png;base64,iVBO...).\n// ':' and ';' inside of it should be threated as is. (Just like in strings.)\nrParenthesis = '\\\\(' + g('[^\\'\"()\\\\\\\\]+', rEscape, rSingleQuotes, rQuotes) + '*?' + '\\\\)',\n    // The value. It can have strings and parentheses (see above). Fallbacks to anything in case of unexpected input.\nrValue = '\\\\s*(' + g('[^\\'\"();\\\\\\\\]+?', rEscape, rSingleQuotes, rQuotes, rParenthesis, '[^;]*?') + '*?' + ')',\n    // End of declaration. Spaces outside of capturing groups help to do natural trimming.\nrDeclEnd = '\\\\s*(?:;\\\\s*|$)',\n    // Final RegExp to parse CSS declarations.\nregDeclarationBlock = new RegExp(rAttr + ':' + rValue + rDeclEnd, 'ig'),\n    // Comments expression. Honors escape sequences and strings.\nregStripComments = new RegExp(g(rEscape, rSingleQuotes, rQuotes, '/\\\\*[^]*?\\\\*/'), 'ig');\n/**\n * Convert style in attributes. Cleanups comments and illegal declarations (without colon) as a side effect.\n *\n * @example\n * <g style=\"fill:#000; color: #fff;\">\n *             ⬇\n * <g fill=\"#000\" color=\"#fff\">\n *\n * @example\n * <g style=\"fill:#000; color: #fff; -webkit-blah: blah\">\n *             ⬇\n * <g fill=\"#000\" color=\"#fff\" style=\"-webkit-blah: blah\">\n *\n * @param {Object} item current iteration item\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\n\nexports.fn = function (item) {\n  /* jshint boss: true */\n  if (item.elem && item.hasAttr('style')) {\n    // ['opacity: 1', 'color: #000']\n    var styleValue = item.attr('style').value,\n        styles = [],\n        attrs = {}; // Strip CSS comments preserving escape sequences and strings.\n\n    styleValue = styleValue.replace(regStripComments, function (match) {\n      return match[0] == '/' ? '' : match[0] == '\\\\' && /[-g-z]/i.test(match[1]) ? match[1] : match;\n    });\n    regDeclarationBlock.lastIndex = 0;\n\n    for (var rule; rule = regDeclarationBlock.exec(styleValue);) {\n      styles.push([rule[1], rule[2]]);\n    }\n\n    if (styles.length) {\n      styles = styles.filter(function (style) {\n        if (style[0]) {\n          var prop = style[0].toLowerCase(),\n              val = style[1];\n\n          if (rQuotedString.test(val)) {\n            val = val.slice(1, -1);\n          }\n\n          if (stylingProps.indexOf(prop) > -1) {\n            attrs[prop] = {\n              name: prop,\n              value: val,\n              local: prop,\n              prefix: ''\n            };\n            return false;\n          }\n        }\n\n        return true;\n      });\n      EXTEND(item.attrs, attrs);\n\n      if (styles.length) {\n        item.attr('style').value = styles.map(function (declaration) {\n          return declaration.join(':');\n        }).join(';');\n      } else {\n        item.removeAttr('style');\n      }\n    }\n  }\n};\n\nfunction g() {\n  return '(?:' + Array.prototype.join.call(arguments, '|') + ')';\n}","map":null,"metadata":{},"sourceType":"script"}