{"ast":null,"code":"'use strict';\n\nvar TokenType = require('./const').TokenType;\n\nvar Scanner = require('./scanner');\n\nvar List = require('../utils/list');\n\nvar needPositions;\nvar filename;\nvar scanner;\nvar SCOPE_ATRULE_EXPRESSION = 1;\nvar SCOPE_SELECTOR = 2;\nvar SCOPE_VALUE = 3;\nvar specialFunctions = {};\nspecialFunctions[SCOPE_ATRULE_EXPRESSION] = {\n  url: getUri\n};\nspecialFunctions[SCOPE_SELECTOR] = {\n  url: getUri,\n  not: getNotFunction\n};\nspecialFunctions[SCOPE_VALUE] = {\n  url: getUri,\n  expression: getOldIEExpression,\n  var: getVarFunction\n};\nvar initialContext = {\n  stylesheet: getStylesheet,\n  atrule: getAtrule,\n  atruleExpression: getAtruleExpression,\n  ruleset: getRuleset,\n  selector: getSelector,\n  simpleSelector: getSimpleSelector,\n  block: getBlock,\n  declaration: getDeclaration,\n  value: getValue\n};\nvar blockMode = {\n  'declaration': true,\n  'property': true\n};\n\nfunction parseError(message) {\n  var error = new Error(message);\n  var line = 1;\n  var column = 1;\n  var lines;\n\n  if (scanner.token !== null) {\n    line = scanner.token.line;\n    column = scanner.token.column;\n  } else if (scanner.prevToken !== null) {\n    lines = scanner.prevToken.value.trimRight().split(/\\n|\\r\\n?|\\f/);\n    line = scanner.prevToken.line + lines.length - 1;\n    column = lines.length > 1 ? lines[lines.length - 1].length + 1 : scanner.prevToken.column + lines[lines.length - 1].length;\n  }\n\n  error.name = 'CssSyntaxError';\n  error.parseError = {\n    line: line,\n    column: column\n  };\n  throw error;\n}\n\nfunction eat(tokenType) {\n  if (scanner.token !== null && scanner.token.type === tokenType) {\n    scanner.next();\n    return true;\n  }\n\n  parseError(tokenType + ' is expected');\n}\n\nfunction expectIdentifier(name, eat) {\n  if (scanner.token !== null) {\n    if (scanner.token.type === TokenType.Identifier && scanner.token.value.toLowerCase() === name) {\n      if (eat) {\n        scanner.next();\n      }\n\n      return true;\n    }\n  }\n\n  parseError('Identifier `' + name + '` is expected');\n}\n\nfunction expectAny(what) {\n  if (scanner.token !== null) {\n    for (var i = 1, type = scanner.token.type; i < arguments.length; i++) {\n      if (type === arguments[i]) {\n        return true;\n      }\n    }\n  }\n\n  parseError(what + ' is expected');\n}\n\nfunction getInfo() {\n  if (needPositions && scanner.token) {\n    return {\n      source: filename,\n      offset: scanner.token.offset,\n      line: scanner.token.line,\n      column: scanner.token.column\n    };\n  }\n\n  return null;\n}\n\nfunction removeTrailingSpaces(list) {\n  while (list.tail) {\n    if (list.tail.data.type === 'Space') {\n      list.remove(list.tail);\n    } else {\n      break;\n    }\n  }\n}\n\nfunction getStylesheet(nested) {\n  var child = null;\n  var node = {\n    type: 'StyleSheet',\n    info: getInfo(),\n    rules: new List()\n  };\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.Space:\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.Comment:\n        // ignore comments except exclamation comments on top level\n        if (nested || scanner.token.value.charAt(2) !== '!') {\n          scanner.next();\n          child = null;\n        } else {\n          child = getComment();\n        }\n\n        break;\n\n      case TokenType.Unknown:\n        child = getUnknown();\n        break;\n\n      case TokenType.CommercialAt:\n        child = getAtrule();\n        break;\n\n      case TokenType.RightCurlyBracket:\n        if (!nested) {\n          parseError('Unexpected right curly brace');\n        }\n\n        break scan;\n\n      default:\n        child = getRuleset();\n    }\n\n    if (child !== null) {\n      node.rules.insert(List.createItem(child));\n    }\n  }\n\n  return node;\n} // '//' ...\n// TODO: remove it as wrong thing\n\n\nfunction getUnknown() {\n  var info = getInfo();\n  var value = scanner.token.value;\n  eat(TokenType.Unknown);\n  return {\n    type: 'Unknown',\n    info: info,\n    value: value\n  };\n}\n\nfunction isBlockAtrule() {\n  for (var offset = 1, cursor; cursor = scanner.lookup(offset); offset++) {\n    var type = cursor.type;\n\n    if (type === TokenType.RightCurlyBracket) {\n      return true;\n    }\n\n    if (type === TokenType.LeftCurlyBracket || type === TokenType.CommercialAt) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getAtruleExpression() {\n  var child = null;\n  var node = {\n    type: 'AtruleExpression',\n    info: getInfo(),\n    sequence: new List()\n  };\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.Semicolon:\n        break scan;\n\n      case TokenType.LeftCurlyBracket:\n        break scan;\n\n      case TokenType.Space:\n        if (node.sequence.isEmpty()) {\n          scanner.next(); // ignore spaces in beginning\n\n          child = null;\n        } else {\n          child = getS();\n        }\n\n        break;\n\n      case TokenType.Comment:\n        // ignore comments\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.Comma:\n        child = getOperator();\n        break;\n\n      case TokenType.Colon:\n        child = getPseudo();\n        break;\n\n      case TokenType.LeftParenthesis:\n        child = getBraces(SCOPE_ATRULE_EXPRESSION);\n        break;\n\n      default:\n        child = getAny(SCOPE_ATRULE_EXPRESSION);\n    }\n\n    if (child !== null) {\n      node.sequence.insert(List.createItem(child));\n    }\n  }\n\n  removeTrailingSpaces(node.sequence);\n  return node;\n}\n\nfunction getAtrule() {\n  eat(TokenType.CommercialAt);\n  var node = {\n    type: 'Atrule',\n    info: getInfo(),\n    name: readIdent(false),\n    expression: getAtruleExpression(),\n    block: null\n  };\n\n  if (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.Semicolon:\n        scanner.next(); // {\n\n        break;\n\n      case TokenType.LeftCurlyBracket:\n        scanner.next(); // {\n\n        if (isBlockAtrule()) {\n          node.block = getBlock();\n        } else {\n          node.block = getStylesheet(true);\n        }\n\n        eat(TokenType.RightCurlyBracket);\n        break;\n\n      default:\n        parseError('Unexpected input');\n    }\n  }\n\n  return node;\n}\n\nfunction getRuleset() {\n  return {\n    type: 'Ruleset',\n    info: getInfo(),\n    selector: getSelector(),\n    block: getBlockWithBrackets()\n  };\n}\n\nfunction getSelector() {\n  var isBadSelector = false;\n  var lastComma = true;\n  var node = {\n    type: 'Selector',\n    info: getInfo(),\n    selectors: new List()\n  };\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.LeftCurlyBracket:\n        break scan;\n\n      case TokenType.Comma:\n        if (lastComma) {\n          isBadSelector = true;\n        }\n\n        lastComma = true;\n        scanner.next();\n        break;\n\n      default:\n        if (!lastComma) {\n          isBadSelector = true;\n        }\n\n        lastComma = false;\n        node.selectors.insert(List.createItem(getSimpleSelector()));\n\n        if (node.selectors.tail.data.sequence.isEmpty()) {\n          isBadSelector = true;\n        }\n\n    }\n  }\n\n  if (lastComma) {\n    isBadSelector = true; // parseError('Unexpected trailing comma');\n  }\n\n  if (isBadSelector) {\n    node.selectors = new List();\n  }\n\n  return node;\n}\n\nfunction getSimpleSelector(nested) {\n  var child = null;\n  var combinator = null;\n  var node = {\n    type: 'SimpleSelector',\n    info: getInfo(),\n    sequence: new List()\n  };\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.Comma:\n        break scan;\n\n      case TokenType.LeftCurlyBracket:\n        if (nested) {\n          parseError('Unexpected input');\n        }\n\n        break scan;\n\n      case TokenType.RightParenthesis:\n        if (!nested) {\n          parseError('Unexpected input');\n        }\n\n        break scan;\n\n      case TokenType.Comment:\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.Space:\n        child = null;\n\n        if (!combinator && node.sequence.head) {\n          combinator = getCombinator();\n        } else {\n          scanner.next();\n        }\n\n        break;\n\n      case TokenType.PlusSign:\n      case TokenType.GreaterThanSign:\n      case TokenType.Tilde:\n      case TokenType.Solidus:\n        if (combinator && combinator.name !== ' ') {\n          parseError('Unexpected combinator');\n        }\n\n        child = null;\n        combinator = getCombinator();\n        break;\n\n      case TokenType.FullStop:\n        child = getClass();\n        break;\n\n      case TokenType.LeftSquareBracket:\n        child = getAttribute();\n        break;\n\n      case TokenType.NumberSign:\n        child = getShash();\n        break;\n\n      case TokenType.Colon:\n        child = getPseudo();\n        break;\n\n      case TokenType.LowLine:\n      case TokenType.Identifier:\n      case TokenType.Asterisk:\n        child = getNamespacedIdentifier(false);\n        break;\n\n      case TokenType.HyphenMinus:\n      case TokenType.DecimalNumber:\n        child = tryGetPercentage() || getNamespacedIdentifier(false);\n        break;\n\n      default:\n        parseError('Unexpected input');\n    }\n\n    if (child !== null) {\n      if (combinator !== null) {\n        node.sequence.insert(List.createItem(combinator));\n        combinator = null;\n      }\n\n      node.sequence.insert(List.createItem(child));\n    }\n  }\n\n  if (combinator && combinator.name !== ' ') {\n    parseError('Unexpected combinator');\n  }\n\n  return node;\n}\n\nfunction getDeclarations() {\n  var child = null;\n  var declarations = new List();\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.RightCurlyBracket:\n        break scan;\n\n      case TokenType.Space:\n      case TokenType.Comment:\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.Semicolon:\n        // ;\n        scanner.next();\n        child = null;\n        break;\n\n      default:\n        child = getDeclaration();\n    }\n\n    if (child !== null) {\n      declarations.insert(List.createItem(child));\n    }\n  }\n\n  return declarations;\n}\n\nfunction getBlockWithBrackets() {\n  var info = getInfo();\n  var node;\n  eat(TokenType.LeftCurlyBracket);\n  node = {\n    type: 'Block',\n    info: info,\n    declarations: getDeclarations()\n  };\n  eat(TokenType.RightCurlyBracket);\n  return node;\n}\n\nfunction getBlock() {\n  return {\n    type: 'Block',\n    info: getInfo(),\n    declarations: getDeclarations()\n  };\n}\n\nfunction getDeclaration(nested) {\n  var info = getInfo();\n  var property = getProperty();\n  var value;\n  eat(TokenType.Colon); // check it's a filter\n\n  if (/filter$/.test(property.name.toLowerCase()) && checkProgid()) {\n    value = getFilterValue();\n  } else {\n    value = getValue(nested);\n  }\n\n  return {\n    type: 'Declaration',\n    info: info,\n    property: property,\n    value: value\n  };\n}\n\nfunction getProperty() {\n  var name = '';\n  var node = {\n    type: 'Property',\n    info: getInfo(),\n    name: null\n  };\n\n  for (; scanner.token !== null; scanner.next()) {\n    var type = scanner.token.type;\n\n    if (type !== TokenType.Solidus && type !== TokenType.Asterisk && type !== TokenType.DollarSign) {\n      break;\n    }\n\n    name += scanner.token.value;\n  }\n\n  node.name = name + readIdent(true);\n  readSC();\n  return node;\n}\n\nfunction getValue(nested) {\n  var child = null;\n  var node = {\n    type: 'Value',\n    info: getInfo(),\n    important: false,\n    sequence: new List()\n  };\n  readSC();\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.RightCurlyBracket:\n      case TokenType.Semicolon:\n        break scan;\n\n      case TokenType.RightParenthesis:\n        if (!nested) {\n          parseError('Unexpected input');\n        }\n\n        break scan;\n\n      case TokenType.Space:\n        child = getS();\n        break;\n\n      case TokenType.Comment:\n        // ignore comments\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.NumberSign:\n        child = getVhash();\n        break;\n\n      case TokenType.Solidus:\n      case TokenType.Comma:\n        child = getOperator();\n        break;\n\n      case TokenType.LeftParenthesis:\n      case TokenType.LeftSquareBracket:\n        child = getBraces(SCOPE_VALUE);\n        break;\n\n      case TokenType.ExclamationMark:\n        node.important = getImportant();\n        child = null;\n        break;\n\n      default:\n        // check for unicode range: U+0F00, U+0F00-0FFF, u+0F00??\n        if (scanner.token.type === TokenType.Identifier) {\n          var prefix = scanner.token.value;\n\n          if (prefix === 'U' || prefix === 'u') {\n            if (scanner.lookupType(1, TokenType.PlusSign)) {\n              scanner.next(); // U or u\n\n              scanner.next(); // +\n\n              child = {\n                type: 'Identifier',\n                info: getInfo(),\n                // FIXME: wrong position\n                name: prefix + '+' + readUnicodeRange(true)\n              };\n            }\n\n            break;\n          }\n        }\n\n        child = getAny(SCOPE_VALUE);\n    }\n\n    if (child !== null) {\n      node.sequence.insert(List.createItem(child));\n    }\n  }\n\n  removeTrailingSpaces(node.sequence);\n  return node;\n} // any = string | percentage | dimension | number | uri | functionExpression | funktion | unary | operator | ident\n\n\nfunction getAny(scope) {\n  switch (scanner.token.type) {\n    case TokenType.String:\n      return getString();\n\n    case TokenType.LowLine:\n    case TokenType.Identifier:\n      break;\n\n    case TokenType.FullStop:\n    case TokenType.DecimalNumber:\n    case TokenType.HyphenMinus:\n    case TokenType.PlusSign:\n      var number = tryGetNumber();\n\n      if (number !== null) {\n        if (scanner.token !== null) {\n          if (scanner.token.type === TokenType.PercentSign) {\n            return getPercentage(number);\n          } else if (scanner.token.type === TokenType.Identifier) {\n            return getDimension(number.value);\n          }\n        }\n\n        return number;\n      }\n\n      if (scanner.token.type === TokenType.HyphenMinus) {\n        var next = scanner.lookup(1);\n\n        if (next && (next.type === TokenType.Identifier || next.type === TokenType.HyphenMinus)) {\n          break;\n        }\n      }\n\n      if (scanner.token.type === TokenType.HyphenMinus || scanner.token.type === TokenType.PlusSign) {\n        return getOperator();\n      }\n\n      parseError('Unexpected input');\n\n    default:\n      parseError('Unexpected input');\n  }\n\n  var ident = getIdentifier(false);\n\n  if (scanner.token !== null && scanner.token.type === TokenType.LeftParenthesis) {\n    return getFunction(scope, ident);\n  }\n\n  return ident;\n}\n\nfunction readAttrselector() {\n  expectAny('Attribute selector (=, ~=, ^=, $=, *=, |=)', TokenType.EqualsSign, // =\n  TokenType.Tilde, // ~=\n  TokenType.CircumflexAccent, // ^=\n  TokenType.DollarSign, // $=\n  TokenType.Asterisk, // *=\n  TokenType.VerticalLine // |=\n  );\n  var name;\n\n  if (scanner.token.type === TokenType.EqualsSign) {\n    name = '=';\n    scanner.next();\n  } else {\n    name = scanner.token.value + '=';\n    scanner.next();\n    eat(TokenType.EqualsSign);\n  }\n\n  return name;\n} // '[' S* attrib_name ']'\n// '[' S* attrib_name S* attrib_match S* [ IDENT | STRING ] S* attrib_flags? S* ']'\n\n\nfunction getAttribute() {\n  var node = {\n    type: 'Attribute',\n    info: getInfo(),\n    name: null,\n    operator: null,\n    value: null,\n    flags: null\n  };\n  eat(TokenType.LeftSquareBracket);\n  readSC();\n  node.name = getNamespacedIdentifier(true);\n  readSC();\n\n  if (scanner.token !== null && scanner.token.type !== TokenType.RightSquareBracket) {\n    node.operator = readAttrselector();\n    readSC();\n\n    if (scanner.token !== null && scanner.token.type === TokenType.String) {\n      node.value = getString();\n    } else {\n      node.value = getIdentifier(false);\n    }\n\n    readSC(); // attribute flags\n\n    if (scanner.token !== null && scanner.token.type === TokenType.Identifier) {\n      node.flags = scanner.token.value;\n      scanner.next();\n      readSC();\n    }\n  }\n\n  eat(TokenType.RightSquareBracket);\n  return node;\n}\n\nfunction getBraces(scope) {\n  var close;\n  var child = null;\n  var node = {\n    type: 'Braces',\n    info: getInfo(),\n    open: scanner.token.value,\n    close: null,\n    sequence: new List()\n  };\n\n  if (scanner.token.type === TokenType.LeftParenthesis) {\n    close = TokenType.RightParenthesis;\n  } else {\n    close = TokenType.RightSquareBracket;\n  } // left brace\n\n\n  scanner.next();\n  readSC();\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case close:\n        node.close = scanner.token.value;\n        break scan;\n\n      case TokenType.Space:\n        child = getS();\n        break;\n\n      case TokenType.Comment:\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.NumberSign:\n        // ??\n        child = getVhash();\n        break;\n\n      case TokenType.LeftParenthesis:\n      case TokenType.LeftSquareBracket:\n        child = getBraces(scope);\n        break;\n\n      case TokenType.Solidus:\n      case TokenType.Asterisk:\n      case TokenType.Comma:\n      case TokenType.Colon:\n        child = getOperator();\n        break;\n\n      default:\n        child = getAny(scope);\n    }\n\n    if (child !== null) {\n      node.sequence.insert(List.createItem(child));\n    }\n  }\n\n  removeTrailingSpaces(node.sequence); // right brace\n\n  eat(close);\n  return node;\n} // '.' ident\n\n\nfunction getClass() {\n  var info = getInfo();\n  eat(TokenType.FullStop);\n  return {\n    type: 'Class',\n    info: info,\n    name: readIdent(false)\n  };\n} // '#' ident\n\n\nfunction getShash() {\n  var info = getInfo();\n  eat(TokenType.NumberSign);\n  return {\n    type: 'Id',\n    info: info,\n    name: readIdent(false)\n  };\n} // + | > | ~ | /deep/\n\n\nfunction getCombinator() {\n  var info = getInfo();\n  var combinator;\n\n  switch (scanner.token.type) {\n    case TokenType.Space:\n      combinator = ' ';\n      scanner.next();\n      break;\n\n    case TokenType.PlusSign:\n    case TokenType.GreaterThanSign:\n    case TokenType.Tilde:\n      combinator = scanner.token.value;\n      scanner.next();\n      break;\n\n    case TokenType.Solidus:\n      combinator = '/deep/';\n      scanner.next();\n      expectIdentifier('deep', true);\n      eat(TokenType.Solidus);\n      break;\n\n    default:\n      parseError('Combinator (+, >, ~, /deep/) is expected');\n  }\n\n  return {\n    type: 'Combinator',\n    info: info,\n    name: combinator\n  };\n} // '/*' .* '*/'\n\n\nfunction getComment() {\n  var info = getInfo();\n  var value = scanner.token.value;\n  var len = value.length;\n\n  if (len > 4 && value.charAt(len - 2) === '*' && value.charAt(len - 1) === '/') {\n    len -= 2;\n  }\n\n  scanner.next();\n  return {\n    type: 'Comment',\n    info: info,\n    value: value.substring(2, len)\n  };\n} // special reader for units to avoid adjoined IE hacks (i.e. '1px\\9')\n\n\nfunction readUnit() {\n  if (scanner.token !== null && scanner.token.type === TokenType.Identifier) {\n    var unit = scanner.token.value;\n    var backSlashPos = unit.indexOf('\\\\'); // no backslash in unit name\n\n    if (backSlashPos === -1) {\n      scanner.next();\n      return unit;\n    } // patch token\n\n\n    scanner.token.value = unit.substr(backSlashPos);\n    scanner.token.offset += backSlashPos;\n    scanner.token.column += backSlashPos; // return unit w/o backslash part\n\n    return unit.substr(0, backSlashPos);\n  }\n\n  parseError('Identifier is expected');\n} // number ident\n\n\nfunction getDimension(number) {\n  return {\n    type: 'Dimension',\n    info: getInfo(),\n    value: number || readNumber(),\n    unit: readUnit()\n  };\n} // number \"%\"\n\n\nfunction tryGetPercentage() {\n  var number = tryGetNumber();\n\n  if (number && scanner.token !== null && scanner.token.type === TokenType.PercentSign) {\n    return getPercentage(number);\n  }\n\n  return null;\n}\n\nfunction getPercentage(number) {\n  var info;\n\n  if (!number) {\n    info = getInfo();\n    number = readNumber();\n  } else {\n    info = number.info;\n    number = number.value;\n  }\n\n  eat(TokenType.PercentSign);\n  return {\n    type: 'Percentage',\n    info: info,\n    value: number\n  };\n} // ident '(' functionBody ')' |\n// not '(' <simpleSelector>* ')'\n\n\nfunction getFunction(scope, ident) {\n  var defaultArguments = getFunctionArguments;\n\n  if (!ident) {\n    ident = getIdentifier(false);\n  } // parse special functions\n\n\n  var name = ident.name.toLowerCase();\n\n  if (specialFunctions.hasOwnProperty(scope)) {\n    if (specialFunctions[scope].hasOwnProperty(name)) {\n      return specialFunctions[scope][name](scope, ident);\n    }\n  }\n\n  return getFunctionInternal(defaultArguments, scope, ident);\n}\n\nfunction getFunctionInternal(functionArgumentsReader, scope, ident) {\n  var args;\n  eat(TokenType.LeftParenthesis);\n  args = functionArgumentsReader(scope);\n  eat(TokenType.RightParenthesis);\n  return {\n    type: scope === SCOPE_SELECTOR ? 'FunctionalPseudo' : 'Function',\n    info: ident.info,\n    name: ident.name,\n    arguments: args\n  };\n}\n\nfunction getFunctionArguments(scope) {\n  var args = new List();\n  var argument = null;\n  var child = null;\n  readSC();\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.RightParenthesis:\n        break scan;\n\n      case TokenType.Space:\n        child = getS();\n        break;\n\n      case TokenType.Comment:\n        // ignore comments\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.NumberSign:\n        // TODO: not sure it should be here\n        child = getVhash();\n        break;\n\n      case TokenType.LeftParenthesis:\n      case TokenType.LeftSquareBracket:\n        child = getBraces(scope);\n        break;\n\n      case TokenType.Comma:\n        removeTrailingSpaces(argument.sequence);\n        scanner.next();\n        readSC();\n        argument = null;\n        child = null;\n        break;\n\n      case TokenType.Solidus:\n      case TokenType.Asterisk:\n      case TokenType.Colon:\n      case TokenType.EqualsSign:\n        child = getOperator();\n        break;\n\n      default:\n        child = getAny(scope);\n    }\n\n    if (argument === null) {\n      argument = {\n        type: 'Argument',\n        sequence: new List()\n      };\n      args.insert(List.createItem(argument));\n    }\n\n    if (child !== null) {\n      argument.sequence.insert(List.createItem(child));\n    }\n  }\n\n  if (argument !== null) {\n    removeTrailingSpaces(argument.sequence);\n  }\n\n  return args;\n}\n\nfunction getVarFunction(scope, ident) {\n  return getFunctionInternal(getVarFunctionArguments, scope, ident);\n}\n\nfunction getNotFunctionArguments() {\n  var args = new List();\n  var wasSelector = false;\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.RightParenthesis:\n        if (!wasSelector) {\n          parseError('Simple selector is expected');\n        }\n\n        break scan;\n\n      case TokenType.Comma:\n        if (!wasSelector) {\n          parseError('Simple selector is expected');\n        }\n\n        wasSelector = false;\n        scanner.next();\n        break;\n\n      default:\n        wasSelector = true;\n        args.insert(List.createItem(getSimpleSelector(true)));\n    }\n  }\n\n  return args;\n}\n\nfunction getNotFunction(scope, ident) {\n  var args;\n  eat(TokenType.LeftParenthesis);\n  args = getNotFunctionArguments(scope);\n  eat(TokenType.RightParenthesis);\n  return {\n    type: 'Negation',\n    info: ident.info,\n    // name: ident.name,  // TODO: add name?\n    sequence: args // FIXME: -> arguments?\n\n  };\n} // var '(' ident (',' <declaration-value>)? ')'\n\n\nfunction getVarFunctionArguments() {\n  // TODO: special type Variable?\n  var args = new List();\n  readSC();\n  args.insert(List.createItem({\n    type: 'Argument',\n    sequence: new List([getIdentifier(true)])\n  }));\n  readSC();\n\n  if (scanner.token !== null && scanner.token.type === TokenType.Comma) {\n    eat(TokenType.Comma);\n    readSC();\n    args.insert(List.createItem({\n      type: 'Argument',\n      sequence: new List([getValue(true)])\n    }));\n    readSC();\n  }\n\n  return args;\n} // url '(' ws* (string | raw) ws* ')'\n\n\nfunction getUri(scope, ident) {\n  var node = {\n    type: 'Url',\n    info: ident.info,\n    // name: ident.name,\n    value: null\n  };\n  eat(TokenType.LeftParenthesis); // (\n\n  readSC();\n\n  if (scanner.token.type === TokenType.String) {\n    node.value = getString();\n    readSC();\n  } else {\n    var rawInfo = getInfo();\n    var raw = '';\n\n    for (; scanner.token !== null; scanner.next()) {\n      var type = scanner.token.type;\n\n      if (type === TokenType.Space || type === TokenType.LeftParenthesis || type === TokenType.RightParenthesis) {\n        break;\n      }\n\n      raw += scanner.token.value;\n    }\n\n    node.value = {\n      type: 'Raw',\n      info: rawInfo,\n      value: raw\n    };\n    readSC();\n  }\n\n  eat(TokenType.RightParenthesis); // )\n\n  return node;\n} // expression '(' raw ')'\n\n\nfunction getOldIEExpression(scope, ident) {\n  var balance = 0;\n  var raw = '';\n  eat(TokenType.LeftParenthesis);\n\n  for (; scanner.token !== null; scanner.next()) {\n    if (scanner.token.type === TokenType.RightParenthesis) {\n      if (balance === 0) {\n        break;\n      }\n\n      balance--;\n    } else if (scanner.token.type === TokenType.LeftParenthesis) {\n      balance++;\n    }\n\n    raw += scanner.token.value;\n  }\n\n  eat(TokenType.RightParenthesis);\n  return {\n    type: 'Function',\n    info: ident.info,\n    name: ident.name,\n    arguments: new List([{\n      type: 'Argument',\n      sequence: new List([{\n        type: 'Raw',\n        value: raw\n      }])\n    }])\n  };\n}\n\nfunction readUnicodeRange(tryNext) {\n  var hex = '';\n\n  for (; scanner.token !== null; scanner.next()) {\n    if (scanner.token.type !== TokenType.DecimalNumber && scanner.token.type !== TokenType.Identifier) {\n      break;\n    }\n\n    hex += scanner.token.value;\n  }\n\n  if (!/^[0-9a-f]{1,6}$/i.test(hex)) {\n    parseError('Unexpected input');\n  } // U+abc???\n\n\n  if (tryNext) {\n    for (; hex.length < 6 && scanner.token !== null; scanner.next()) {\n      if (scanner.token.type !== TokenType.QuestionMark) {\n        break;\n      }\n\n      hex += scanner.token.value;\n      tryNext = false;\n    }\n  } // U+aaa-bbb\n\n\n  if (tryNext) {\n    if (scanner.token !== null && scanner.token.type === TokenType.HyphenMinus) {\n      scanner.next();\n      var next = readUnicodeRange(false);\n\n      if (!next) {\n        parseError('Unexpected input');\n      }\n\n      hex += '-' + next;\n    }\n  }\n\n  return hex;\n}\n\nfunction readIdent(varAllowed) {\n  var name = ''; // optional first -\n\n  if (scanner.token !== null && scanner.token.type === TokenType.HyphenMinus) {\n    name = '-';\n    scanner.next();\n\n    if (varAllowed && scanner.token !== null && scanner.token.type === TokenType.HyphenMinus) {\n      name = '--';\n      scanner.next();\n    }\n  }\n\n  expectAny('Identifier', TokenType.LowLine, TokenType.Identifier);\n\n  if (scanner.token !== null) {\n    name += scanner.token.value;\n    scanner.next();\n\n    for (; scanner.token !== null; scanner.next()) {\n      var type = scanner.token.type;\n\n      if (type !== TokenType.LowLine && type !== TokenType.Identifier && type !== TokenType.DecimalNumber && type !== TokenType.HyphenMinus) {\n        break;\n      }\n\n      name += scanner.token.value;\n    }\n  }\n\n  return name;\n}\n\nfunction getNamespacedIdentifier(checkColon) {\n  if (scanner.token === null) {\n    parseError('Unexpected end of input');\n  }\n\n  var info = getInfo();\n  var name;\n\n  if (scanner.token.type === TokenType.Asterisk) {\n    checkColon = false;\n    name = '*';\n    scanner.next();\n  } else {\n    name = readIdent(false);\n  }\n\n  if (scanner.token !== null) {\n    if (scanner.token.type === TokenType.VerticalLine && scanner.lookupType(1, TokenType.EqualsSign) === false) {\n      name += '|';\n\n      if (scanner.next() !== null) {\n        if (scanner.token.type === TokenType.HyphenMinus || scanner.token.type === TokenType.Identifier || scanner.token.type === TokenType.LowLine) {\n          name += readIdent(false);\n        } else if (scanner.token.type === TokenType.Asterisk) {\n          checkColon = false;\n          name += '*';\n          scanner.next();\n        }\n      }\n    }\n  }\n\n  if (checkColon && scanner.token !== null && scanner.token.type === TokenType.Colon) {\n    scanner.next();\n    name += ':' + readIdent(false);\n  }\n\n  return {\n    type: 'Identifier',\n    info: info,\n    name: name\n  };\n}\n\nfunction getIdentifier(varAllowed) {\n  return {\n    type: 'Identifier',\n    info: getInfo(),\n    name: readIdent(varAllowed)\n  };\n} // ! ws* important\n\n\nfunction getImportant() {\n  // TODO?\n  // var info = getInfo();\n  eat(TokenType.ExclamationMark);\n  readSC(); // return {\n  //     type: 'Identifier',\n  //     info: info,\n  //     name: readIdent(false)\n  // };\n\n  expectIdentifier('important');\n  readIdent(false); // should return identifier in future for original source restoring as is\n  // returns true for now since it's fit to optimizer purposes\n\n  return true;\n} // odd | even | number? n\n\n\nfunction getNth() {\n  expectAny('Number, odd or even', TokenType.Identifier, TokenType.DecimalNumber);\n  var info = getInfo();\n  var value = scanner.token.value;\n  var cmpValue;\n\n  if (scanner.token.type === TokenType.DecimalNumber) {\n    var next = scanner.lookup(1);\n\n    if (next !== null && next.type === TokenType.Identifier && next.value.toLowerCase() === 'n') {\n      value += next.value;\n      scanner.next();\n    }\n  } else {\n    var cmpValue = value.toLowerCase();\n\n    if (cmpValue !== 'odd' && cmpValue !== 'even' && cmpValue !== 'n') {\n      parseError('Unexpected identifier');\n    }\n  }\n\n  scanner.next();\n  return {\n    type: 'Nth',\n    info: info,\n    value: value\n  };\n}\n\nfunction getNthSelector() {\n  var info = getInfo();\n  var sequence = new List();\n  var node;\n  var child = null;\n  eat(TokenType.Colon);\n  expectIdentifier('nth', false);\n  node = {\n    type: 'FunctionalPseudo',\n    info: info,\n    name: readIdent(false),\n    arguments: new List([{\n      type: 'Argument',\n      sequence: sequence\n    }])\n  };\n  eat(TokenType.LeftParenthesis);\n\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.RightParenthesis:\n        break scan;\n\n      case TokenType.Space:\n      case TokenType.Comment:\n        scanner.next();\n        child = null;\n        break;\n\n      case TokenType.HyphenMinus:\n      case TokenType.PlusSign:\n        child = getOperator();\n        break;\n\n      default:\n        child = getNth();\n    }\n\n    if (child !== null) {\n      sequence.insert(List.createItem(child));\n    }\n  }\n\n  eat(TokenType.RightParenthesis);\n  return node;\n}\n\nfunction readNumber() {\n  var wasDigits = false;\n  var number = '';\n  var offset = 0;\n\n  if (scanner.lookupType(offset, TokenType.HyphenMinus)) {\n    number = '-';\n    offset++;\n  }\n\n  if (scanner.lookupType(offset, TokenType.DecimalNumber)) {\n    wasDigits = true;\n    number += scanner.lookup(offset).value;\n    offset++;\n  }\n\n  if (scanner.lookupType(offset, TokenType.FullStop)) {\n    number += '.';\n    offset++;\n  }\n\n  if (scanner.lookupType(offset, TokenType.DecimalNumber)) {\n    wasDigits = true;\n    number += scanner.lookup(offset).value;\n    offset++;\n  }\n\n  if (wasDigits) {\n    while (offset--) {\n      scanner.next();\n    }\n\n    return number;\n  }\n\n  return null;\n}\n\nfunction tryGetNumber() {\n  var info = getInfo();\n  var number = readNumber();\n\n  if (number !== null) {\n    return {\n      type: 'Number',\n      info: info,\n      value: number\n    };\n  }\n\n  return null;\n} // '/' | '*' | ',' | ':' | '=' | '+' | '-'\n// TODO: remove '=' since it's wrong operator, but theat as operator\n// to make old things like `filter: alpha(opacity=0)` works\n\n\nfunction getOperator() {\n  var node = {\n    type: 'Operator',\n    info: getInfo(),\n    value: scanner.token.value\n  };\n  scanner.next();\n  return node;\n}\n\nfunction getFilterValue() {\n  // TODO\n  var progid;\n  var node = {\n    type: 'Value',\n    info: getInfo(),\n    important: false,\n    sequence: new List()\n  };\n\n  while (progid = checkProgid()) {\n    node.sequence.insert(List.createItem(getProgid(progid)));\n  }\n\n  readSC(node);\n\n  if (scanner.token !== null && scanner.token.type === TokenType.ExclamationMark) {\n    node.important = getImportant();\n  }\n\n  return node;\n} // 'progid:' ws* 'DXImageTransform.Microsoft.' ident ws* '(' .* ')'\n\n\nfunction checkProgid() {\n  function checkSC(offset) {\n    for (var cursor; cursor = scanner.lookup(offset); offset++) {\n      if (cursor.type !== TokenType.Space && cursor.type !== TokenType.Comment) {\n        break;\n      }\n    }\n\n    return offset;\n  }\n\n  var offset = checkSC(0);\n\n  if (scanner.lookup(offset + 1) === null || scanner.lookup(offset + 0).value.toLowerCase() !== 'progid' || scanner.lookup(offset + 1).type !== TokenType.Colon) {\n    return false; // fail\n  }\n\n  offset += 2;\n  offset = checkSC(offset);\n\n  if (scanner.lookup(offset + 5) === null || scanner.lookup(offset + 0).value.toLowerCase() !== 'dximagetransform' || scanner.lookup(offset + 1).type !== TokenType.FullStop || scanner.lookup(offset + 2).value.toLowerCase() !== 'microsoft' || scanner.lookup(offset + 3).type !== TokenType.FullStop || scanner.lookup(offset + 4).type !== TokenType.Identifier) {\n    return false; // fail\n  }\n\n  offset += 5;\n  offset = checkSC(offset);\n\n  if (scanner.lookupType(offset, TokenType.LeftParenthesis) === false) {\n    return false; // fail\n  }\n\n  for (var cursor; cursor = scanner.lookup(offset); offset++) {\n    if (cursor.type === TokenType.RightParenthesis) {\n      return cursor;\n    }\n  }\n\n  return false;\n}\n\nfunction getProgid(progidEnd) {\n  var value = '';\n  var node = {\n    type: 'Progid',\n    info: getInfo(),\n    value: null\n  };\n\n  if (!progidEnd) {\n    progidEnd = checkProgid();\n  }\n\n  if (!progidEnd) {\n    parseError('progid is expected');\n  }\n\n  readSC(node);\n  var rawInfo = getInfo();\n\n  for (; scanner.token && scanner.token !== progidEnd; scanner.next()) {\n    value += scanner.token.value;\n  }\n\n  eat(TokenType.RightParenthesis);\n  value += ')';\n  node.value = {\n    type: 'Raw',\n    info: rawInfo,\n    value: value\n  };\n  readSC(node);\n  return node;\n} // <pseudo-element> | <nth-selector> | <pseudo-class>\n\n\nfunction getPseudo() {\n  var next = scanner.lookup(1);\n\n  if (next === null) {\n    scanner.next();\n    parseError('Colon or identifier is expected');\n  }\n\n  if (next.type === TokenType.Colon) {\n    return getPseudoElement();\n  }\n\n  if (next.type === TokenType.Identifier && next.value.toLowerCase() === 'nth') {\n    return getNthSelector();\n  }\n\n  return getPseudoClass();\n} // :: ident\n\n\nfunction getPseudoElement() {\n  var info = getInfo();\n  eat(TokenType.Colon);\n  eat(TokenType.Colon);\n  return {\n    type: 'PseudoElement',\n    info: info,\n    name: readIdent(false)\n  };\n} // : ( ident | function )\n\n\nfunction getPseudoClass() {\n  var info = getInfo();\n  var ident = eat(TokenType.Colon) && getIdentifier(false);\n\n  if (scanner.token !== null && scanner.token.type === TokenType.LeftParenthesis) {\n    return getFunction(SCOPE_SELECTOR, ident);\n  }\n\n  return {\n    type: 'PseudoClass',\n    info: info,\n    name: ident.name\n  };\n} // ws\n\n\nfunction getS() {\n  var node = {\n    type: 'Space' // value: scanner.token.value\n\n  };\n  scanner.next();\n  return node;\n}\n\nfunction readSC() {\n  // var nodes = [];\n  scan: while (scanner.token !== null) {\n    switch (scanner.token.type) {\n      case TokenType.Space:\n        scanner.next(); // nodes.push(getS());\n\n        break;\n\n      case TokenType.Comment:\n        scanner.next(); // nodes.push(getComment());\n\n        break;\n\n      default:\n        break scan;\n    }\n  }\n\n  return null; // return nodes.length ? new List(nodes) : null;\n} // node: String\n\n\nfunction getString() {\n  var node = {\n    type: 'String',\n    info: getInfo(),\n    value: scanner.token.value\n  };\n  scanner.next();\n  return node;\n} // # ident\n\n\nfunction getVhash() {\n  var info = getInfo();\n  var value;\n  eat(TokenType.NumberSign);\n  expectAny('Number or identifier', TokenType.DecimalNumber, TokenType.Identifier);\n  value = scanner.token.value;\n\n  if (scanner.token.type === TokenType.DecimalNumber && scanner.lookupType(1, TokenType.Identifier)) {\n    scanner.next();\n    value += scanner.token.value;\n  }\n\n  scanner.next();\n  return {\n    type: 'Hash',\n    info: info,\n    value: value\n  };\n}\n\nmodule.exports = function parse(source, options) {\n  var ast;\n\n  if (!options || typeof options !== 'object') {\n    options = {};\n  }\n\n  var context = options.context || 'stylesheet';\n  needPositions = Boolean(options.positions);\n  filename = options.filename || '<unknown>';\n\n  if (!initialContext.hasOwnProperty(context)) {\n    throw new Error('Unknown context `' + context + '`');\n  }\n\n  scanner = new Scanner(source, blockMode.hasOwnProperty(context), options.line, options.column);\n  scanner.next();\n  ast = initialContext[context]();\n  scanner = null; // console.log(JSON.stringify(ast, null, 4));\n  // console.log(require('../utils/stringify.js')(ast, true));\n\n  return ast;\n};","map":null,"metadata":{},"sourceType":"script"}