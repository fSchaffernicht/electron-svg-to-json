{"ast":null,"code":"'use strict';\n\nvar regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,\n    regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/,\n    regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n/**\n * Convert transform string to JS representation.\n *\n * @param {String} transformString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\nexports.transform2js = function (transformString) {\n  // JS representation of the transform data\n  var transforms = [],\n      // current transform context\n  current; // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n\n  transformString.split(regTransformSplit).forEach(function (item) {\n    /*jshint -W084 */\n    var num;\n\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        transforms.push(current = {\n          name: item\n        }); // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        while (num = regNumericValues.exec(item)) {\n          num = Number(num);\n          if (current.data) current.data.push(num);else current.data = [num];\n        }\n      }\n    }\n  });\n  return transforms;\n};\n/**\n * Multiply transforms into one.\n *\n * @param {Array} input transforms array\n * @return {Array} output matrix array\n */\n\n\nexports.transformsMultiply = function (transforms) {\n  // convert transforms objects to the matrices\n  transforms = transforms.map(function (transform) {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n\n    return transformToMatrix(transform);\n  }); // multiply all matrices into one\n\n  transforms = {\n    name: 'matrix',\n    data: transforms.reduce(function (a, b) {\n      return multiplyTransformMatrices(a, b);\n    })\n  };\n  return transforms;\n};\n/**\n * Do math like a schoolgirl.\n *\n * @type {Object}\n */\n\n\nvar mth = exports.mth = {\n  rad: function rad(deg) {\n    return deg * Math.PI / 180;\n  },\n  deg: function deg(rad) {\n    return rad * 180 / Math.PI;\n  },\n  cos: function cos(deg) {\n    return Math.cos(this.rad(deg));\n  },\n  acos: function acos(val, floatPrecision) {\n    return +this.deg(Math.acos(val)).toFixed(floatPrecision);\n  },\n  sin: function sin(deg) {\n    return Math.sin(this.rad(deg));\n  },\n  asin: function asin(val, floatPrecision) {\n    return +this.deg(Math.asin(val)).toFixed(floatPrecision);\n  },\n  tan: function tan(deg) {\n    return Math.tan(this.rad(deg));\n  },\n  atan: function atan(val, floatPrecision) {\n    return +this.deg(Math.atan(val)).toFixed(floatPrecision);\n  }\n};\n/**\n * Decompose matrix into simple transforms. See\n * http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices\n *\n * @param {Object} data matrix transform object\n * @return {Object|Array} transforms array or original transform object\n */\n\nexports.matrixToTransform = function (transform, params) {\n  var floatPrecision = params.floatPrecision,\n      data = transform.data,\n      transforms = [],\n      sx = +Math.sqrt(data[0] * data[0] + data[1] * data[1]).toFixed(params.transformPrecision),\n      sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision),\n      colsSum = data[0] * data[2] + data[1] * data[3],\n      rowsSum = data[0] * data[1] + data[2] * data[3],\n      scaleBefore = rowsSum || +(sx == sy); // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5)\n    });\n  } // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n\n\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)]\n    }); // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)]\n    });\n    sx = data[0];\n    sy = data[3]; // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.sqrt(data[0] * data[0] + data[2] * data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.sqrt(data[1] * data[1] + data[3] * data[3]);\n      transforms.push({\n        name: 'scale',\n        data: [sx, sy]\n      });\n    }\n\n    var rotate = [mth.acos(data[0] / sx, floatPrecision) * (data[1] * sy < 0 ? -1 : 1)];\n    if (rotate[0]) transforms.push({\n      name: 'rotate',\n      data: rotate\n    });\n    if (rowsSum && colsSum) transforms.push({\n      name: 'skewX',\n      data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n    }); // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n          sin = data[1] / (scaleBefore ? sx : sy),\n          x = data[4] * (scaleBefore || sy),\n          y = data[5] * (scaleBefore || sx),\n          denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    } // Too many transformations, return original matrix if it isn't just a scale/translate\n\n  } else if (data[1] || data[2]) {\n    return transform;\n  }\n\n  if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n    name: 'scale',\n    data: sx == sy ? [sx] : [sx, sy]\n  });\n  return transforms;\n};\n/**\n * Convert transform to the matrix data.\n *\n * @param {Object} transform transform object\n * @return {Array} matrix data\n */\n\n\nfunction transformToMatrix(transform) {\n  if (transform.name === 'matrix') return transform.data;\n  var matrix;\n\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n      break;\n\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      matrix = [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n      break;\n\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n          sin = mth.sin(transform.data[0]),\n          cx = transform.data[1] || 0,\n          cy = transform.data[2] || 0;\n      matrix = [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n      break;\n\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n      break;\n\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n      break;\n  }\n\n  return matrix;\n}\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @param {Array} arc [a, b, rotation in deg]\n * @param {Array} transform transformation matrix\n * @return {Array} arc transformed input arc\n */\n\n\nexports.transformArc = function (arc, transform) {\n  var a = arc[0],\n      b = arc[1],\n      rot = arc[2] * Math.PI / 180,\n      cos = Math.cos(rot),\n      sin = Math.sin(rot),\n      h = Math.pow(arc[5] * cos + arc[6] * sin, 2) / (4 * a * a) + Math.pow(arc[6] * cos - arc[5] * sin, 2) / (4 * b * b);\n\n  if (h > 1) {\n    h = Math.sqrt(h);\n    a *= h;\n    b *= h;\n  }\n\n  var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],\n      m = multiplyTransformMatrices(transform, ellipse),\n      // Decompose the new ellipse matrix\n  lastCol = m[2] * m[2] + m[3] * m[3],\n      squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,\n      root = Math.sqrt((Math.pow(m[0] - m[3], 2) + Math.pow(m[1] + m[2], 2)) * (Math.pow(m[0] + m[3], 2) + Math.pow(m[1] - m[2], 2)));\n\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    var majorAxisSqr = (squareSum + root) / 2,\n        minorAxisSqr = (squareSum - root) / 2,\n        major = Math.abs(majorAxisSqr - lastCol) > 1e-6,\n        sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,\n        rowsSum = m[0] * m[2] + m[1] * m[3],\n        term1 = m[0] * sub + m[2] * rowsSum,\n        term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.sqrt(term1 * term1 + term2 * term2)) * 180 / Math.PI;\n  }\n\n  return arc;\n};\n/**\n * Multiply transformation matrices.\n *\n * @param {Array} a matrix A data\n * @param {Array} b matrix B data\n * @return {Array} result\n */\n\n\nfunction multiplyTransformMatrices(a, b) {\n  return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];\n}","map":null,"metadata":{},"sourceType":"script"}