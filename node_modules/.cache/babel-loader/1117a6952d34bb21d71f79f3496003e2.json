{"ast":null,"code":"var SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nvar SourceNode = require('source-map').SourceNode; // Our own implementation of SourceNode#toStringWithSourceMap,\n// since SourceNode doesn't allow multiple references to original source.\n// Also, as we know structure of result we could be optimize generation\n// (currently it's ~40% faster).\n\n\nfunction walk(node, fn) {\n  for (var chunk, i = 0; i < node.children.length; i++) {\n    chunk = node.children[i];\n\n    if (chunk instanceof SourceNode) {\n      // this is a hack, because source maps doesn't support for 1(generated):N(original)\n      // if (chunk.merged) {\n      //     fn('', chunk);\n      // }\n      walk(chunk, fn);\n    } else {\n      fn(chunk, node);\n    }\n  }\n}\n\nfunction generateSourceMap(root) {\n  var map = new SourceMapGenerator();\n  var css = '';\n  var sourceMappingActive = false;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastIndexOfNewline;\n  var generated = {\n    line: 1,\n    column: 0\n  };\n  var activatedMapping = {\n    generated: generated\n  };\n  walk(root, function (chunk, original) {\n    if (original.line !== null && original.column !== null) {\n      if (lastOriginalLine !== original.line || lastOriginalColumn !== original.column) {\n        map.addMapping({\n          source: original.source,\n          original: original,\n          generated: generated\n        });\n      }\n\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping(activatedMapping);\n      sourceMappingActive = false;\n    }\n\n    css += chunk;\n    lastIndexOfNewline = chunk.lastIndexOf('\\n');\n\n    if (lastIndexOfNewline !== -1) {\n      generated.line += chunk.match(/\\n/g).length;\n      generated.column = chunk.length - lastIndexOfNewline - 1;\n    } else {\n      generated.column += chunk.length;\n    }\n  });\n  return {\n    css: css,\n    map: map\n  };\n}\n\n;\n\nfunction each(list) {\n  if (list.head === null) {\n    return '';\n  }\n\n  if (list.head === list.tail) {\n    return translate(list.head.data);\n  }\n\n  return list.map(translate).join('');\n}\n\nfunction eachDelim(list, delimeter) {\n  if (list.head === null) {\n    return '';\n  }\n\n  if (list.head === list.tail) {\n    return translate(list.head.data);\n  }\n\n  return list.map(translate).join(delimeter);\n}\n\nfunction createAnonymousSourceNode(children) {\n  return new SourceNode(null, null, null, children);\n}\n\nfunction createSourceNode(info, children) {\n  if (info.primary) {\n    // special marker node to add several references to original\n    // var merged = createSourceNode(info.merged, []);\n    // merged.merged = true;\n    // children.unshift(merged);\n    // use recursion, because primary can also has a primary/merged info\n    return createSourceNode(info.primary, children);\n  }\n\n  return new SourceNode(info.line, info.column - 1, info.source, children);\n}\n\nfunction translate(node) {\n  switch (node.type) {\n    case 'StyleSheet':\n      return createAnonymousSourceNode(node.rules.map(translate));\n\n    case 'Atrule':\n      var nodes = ['@', node.name];\n\n      if (node.expression && !node.expression.sequence.isEmpty()) {\n        nodes.push(' ', translate(node.expression));\n      }\n\n      if (node.block) {\n        nodes.push('{', translate(node.block), '}');\n      } else {\n        nodes.push(';');\n      }\n\n      return createSourceNode(node.info, nodes);\n\n    case 'Ruleset':\n      return createAnonymousSourceNode([translate(node.selector), '{', translate(node.block), '}']);\n\n    case 'Selector':\n      return createAnonymousSourceNode(node.selectors.map(translate)).join(',');\n\n    case 'SimpleSelector':\n      return createSourceNode(node.info, node.sequence.map(function (node) {\n        // add extra spaces around /deep/ combinator since comment beginning/ending may to be produced\n        if (node.type === 'Combinator' && node.name === '/deep/') {\n          return ' ' + translate(node) + ' ';\n        }\n\n        return translate(node);\n      }));\n\n    case 'Block':\n      return createAnonymousSourceNode(node.declarations.map(translate)).join(';');\n\n    case 'Declaration':\n      return createSourceNode(node.info, [translate(node.property), ':', translate(node.value)]);\n\n    case 'Value':\n      return node.important ? each(node.sequence) + '!important' : each(node.sequence);\n\n    case 'Attribute':\n      var result = translate(node.name);\n\n      if (node.operator !== null) {\n        result += node.operator;\n\n        if (node.value !== null) {\n          result += translate(node.value);\n\n          if (node.flags !== null) {\n            result += (node.value.type !== 'String' ? ' ' : '') + node.flags;\n          }\n        }\n      }\n\n      return '[' + result + ']';\n\n    case 'FunctionalPseudo':\n      return ':' + node.name + '(' + eachDelim(node.arguments, ',') + ')';\n\n    case 'Function':\n      return node.name + '(' + eachDelim(node.arguments, ',') + ')';\n\n    case 'Negation':\n      return ':not(' + eachDelim(node.sequence, ',') + ')';\n\n    case 'Braces':\n      return node.open + each(node.sequence) + node.close;\n\n    case 'Argument':\n    case 'AtruleExpression':\n      return each(node.sequence);\n\n    case 'Url':\n      return 'url(' + translate(node.value) + ')';\n\n    case 'Progid':\n      return translate(node.value);\n\n    case 'Property':\n      return node.name;\n\n    case 'Combinator':\n      return node.name;\n\n    case 'Identifier':\n      return node.name;\n\n    case 'PseudoClass':\n      return ':' + node.name;\n\n    case 'PseudoElement':\n      return '::' + node.name;\n\n    case 'Class':\n      return '.' + node.name;\n\n    case 'Id':\n      return '#' + node.name;\n\n    case 'Hash':\n      return '#' + node.value;\n\n    case 'Dimension':\n      return node.value + node.unit;\n\n    case 'Nth':\n      return node.value;\n\n    case 'Number':\n      return node.value;\n\n    case 'String':\n      return node.value;\n\n    case 'Operator':\n      return node.value;\n\n    case 'Raw':\n      return node.value;\n\n    case 'Unknown':\n      return node.value;\n\n    case 'Percentage':\n      return node.value + '%';\n\n    case 'Space':\n      return ' ';\n\n    case 'Comment':\n      return '/*' + node.value + '*/';\n\n    default:\n      throw new Error('Unknown node type: ' + node.type);\n  }\n}\n\nmodule.exports = function (node) {\n  return generateSourceMap(createAnonymousSourceNode(translate(node)));\n};","map":null,"metadata":{},"sourceType":"script"}