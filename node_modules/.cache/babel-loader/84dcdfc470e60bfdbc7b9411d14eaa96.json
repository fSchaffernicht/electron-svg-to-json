{"ast":null,"code":"var List = require('../../utils/list.js');\n\nvar utils = require('./utils.js');\n\nvar walkRulesRight = require('../../utils/walk.js').rulesRight;\n\nfunction calcSelectorLength(list) {\n  var length = 0;\n  list.each(function (data) {\n    length += data.id.length + 1;\n  });\n  return length - 1;\n}\n\nfunction calcDeclarationsLength(tokens) {\n  var length = 0;\n\n  for (var i = 0; i < tokens.length; i++) {\n    length += tokens[i].length;\n  }\n\n  return length + // declarations\n  tokens.length - 1 // delimeters\n  ;\n}\n\nfunction inList(selector) {\n  return selector.compareMarker in this;\n}\n\nfunction processRuleset(node, item, list) {\n  var avoidRulesMerge = this.stylesheet.avoidRulesMerge;\n  var selectors = node.selector.selectors;\n  var block = node.block;\n  var skippedCompareMarkers = Object.create(null);\n  list.prevUntil(item.prev, function (prev, prevItem) {\n    // skip non-ruleset node if safe\n    if (prev.type !== 'Ruleset') {\n      return utils.unsafeToSkipNode.call(selectors, prev);\n    }\n\n    var prevSelectors = prev.selector.selectors;\n    var prevBlock = prev.block;\n\n    if (node.pseudoSignature !== prev.pseudoSignature) {\n      return true;\n    } // try prev ruleset if simpleselectors has no equal specifity and element selector\n\n\n    if (prevSelectors.some(inList, skippedCompareMarkers)) {\n      return true;\n    } // try to join by selectors\n\n\n    if (utils.isEqualLists(prevSelectors, selectors)) {\n      prevBlock.declarations.appendList(block.declarations);\n      list.remove(item);\n      return true;\n    } // try to join by properties\n\n\n    var diff = utils.compareDeclarations(block.declarations, prevBlock.declarations); // console.log(diff.eq, diff.ne1, diff.ne2);\n\n    if (diff.eq.length) {\n      if (!diff.ne1.length && !diff.ne2.length) {\n        // equal blocks\n        utils.addSelectors(selectors, prevSelectors);\n        list.remove(prevItem);\n        return true;\n      } else if (!avoidRulesMerge) {\n        /* probably we don't need to prevent those merges for @keyframes\n           TODO: need to be checked */\n        if (diff.ne1.length && !diff.ne2.length) {\n          // prevBlock is subset block\n          var selectorLength = calcSelectorLength(selectors);\n          var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          if (selectorLength < blockLength) {\n            utils.addSelectors(prevSelectors, selectors);\n            block.declarations = new List(diff.ne1);\n          }\n        } else if (!diff.ne1.length && diff.ne2.length) {\n          // node is subset of prevBlock\n          var selectorLength = calcSelectorLength(prevSelectors);\n          var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          if (selectorLength < blockLength) {\n            utils.addSelectors(selectors, prevSelectors);\n            prevBlock.declarations = new List(diff.ne2);\n          }\n        } else {\n          // diff.ne1.length && diff.ne2.length\n          // extract equal block\n          var newSelector = {\n            type: 'Selector',\n            info: {},\n            selectors: utils.addSelectors(prevSelectors.copy(), selectors)\n          };\n          var newBlockLength = calcSelectorLength(newSelector.selectors) + 2; // selectors length + curly braces length\n\n          var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n          // create new ruleset if declarations length greater than\n          // ruleset description overhead\n\n          if (blockLength >= newBlockLength) {\n            var newRuleset = {\n              type: 'Ruleset',\n              info: {},\n              pseudoSignature: node.pseudoSignature,\n              selector: newSelector,\n              block: {\n                type: 'Block',\n                info: {},\n                declarations: new List(diff.eq)\n              }\n            };\n            block.declarations = new List(diff.ne1);\n            prevBlock.declarations = new List(diff.ne2.concat(diff.ne2overrided));\n            list.insert(list.createItem(newRuleset), prevItem);\n            return true;\n          }\n        }\n      }\n    }\n\n    prevSelectors.each(function (data) {\n      skippedCompareMarkers[data.compareMarker] = true;\n    });\n  });\n}\n\n;\n\nmodule.exports = function restructRuleset(ast) {\n  walkRulesRight(ast, function (node, item, list) {\n    if (node.type === 'Ruleset') {\n      processRuleset.call(this, node, item, list);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}