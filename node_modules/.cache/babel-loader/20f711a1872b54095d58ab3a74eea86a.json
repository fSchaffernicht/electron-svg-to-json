{"ast":null,"code":"function each(list) {\n  if (list.head === null) {\n    return '';\n  }\n\n  if (list.head === list.tail) {\n    return translate(list.head.data);\n  }\n\n  return list.map(translate).join('');\n}\n\nfunction eachDelim(list, delimeter) {\n  if (list.head === null) {\n    return '';\n  }\n\n  if (list.head === list.tail) {\n    return translate(list.head.data);\n  }\n\n  return list.map(translate).join(delimeter);\n}\n\nfunction translate(node) {\n  switch (node.type) {\n    case 'StyleSheet':\n      return each(node.rules);\n\n    case 'Atrule':\n      var result = '@' + node.name;\n\n      if (node.expression && !node.expression.sequence.isEmpty()) {\n        result += ' ' + translate(node.expression);\n      }\n\n      if (node.block) {\n        return result + '{' + translate(node.block) + '}';\n      } else {\n        return result + ';';\n      }\n\n    case 'Ruleset':\n      return translate(node.selector) + '{' + translate(node.block) + '}';\n\n    case 'Selector':\n      return eachDelim(node.selectors, ',');\n\n    case 'SimpleSelector':\n      return node.sequence.map(function (node) {\n        // add extra spaces around /deep/ combinator since comment beginning/ending may to be produced\n        if (node.type === 'Combinator' && node.name === '/deep/') {\n          return ' ' + translate(node) + ' ';\n        }\n\n        return translate(node);\n      }).join('');\n\n    case 'Declaration':\n      return translate(node.property) + ':' + translate(node.value);\n\n    case 'Property':\n      return node.name;\n\n    case 'Value':\n      return node.important ? each(node.sequence) + '!important' : each(node.sequence);\n\n    case 'Attribute':\n      var result = translate(node.name);\n\n      if (node.operator !== null) {\n        result += node.operator;\n\n        if (node.value !== null) {\n          result += translate(node.value);\n\n          if (node.flags !== null) {\n            result += (node.value.type !== 'String' ? ' ' : '') + node.flags;\n          }\n        }\n      }\n\n      return '[' + result + ']';\n\n    case 'FunctionalPseudo':\n      return ':' + node.name + '(' + eachDelim(node.arguments, ',') + ')';\n\n    case 'Function':\n      return node.name + '(' + eachDelim(node.arguments, ',') + ')';\n\n    case 'Block':\n      return eachDelim(node.declarations, ';');\n\n    case 'Negation':\n      return ':not(' + eachDelim(node.sequence, ',') + ')';\n\n    case 'Braces':\n      return node.open + each(node.sequence) + node.close;\n\n    case 'Argument':\n    case 'AtruleExpression':\n      return each(node.sequence);\n\n    case 'Url':\n      return 'url(' + translate(node.value) + ')';\n\n    case 'Progid':\n      return translate(node.value);\n\n    case 'Combinator':\n      return node.name;\n\n    case 'Identifier':\n      return node.name;\n\n    case 'PseudoClass':\n      return ':' + node.name;\n\n    case 'PseudoElement':\n      return '::' + node.name;\n\n    case 'Class':\n      return '.' + node.name;\n\n    case 'Id':\n      return '#' + node.name;\n\n    case 'Hash':\n      return '#' + node.value;\n\n    case 'Dimension':\n      return node.value + node.unit;\n\n    case 'Nth':\n      return node.value;\n\n    case 'Number':\n      return node.value;\n\n    case 'String':\n      return node.value;\n\n    case 'Operator':\n      return node.value;\n\n    case 'Raw':\n      return node.value;\n\n    case 'Unknown':\n      return node.value;\n\n    case 'Percentage':\n      return node.value + '%';\n\n    case 'Space':\n      return ' ';\n\n    case 'Comment':\n      return '/*' + node.value + '*/';\n\n    default:\n      throw new Error('Unknown node type: ' + node.type);\n  }\n}\n\nmodule.exports = translate;","map":null,"metadata":{},"sourceType":"script"}