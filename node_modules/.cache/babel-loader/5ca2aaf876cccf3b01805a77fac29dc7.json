{"ast":null,"code":"'use strict';\n\nexports.type = 'perItem';\nexports.active = true;\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  makeArcs: {\n    threshold: 2.5,\n    // coefficient of rounding error\n    tolerance: 0.5 // percentage of radius\n\n  },\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true\n};\n\nvar pathElems = require('./_collections.js').pathElems,\n    path2js = require('./_path.js').path2js,\n    js2path = require('./_path.js').js2path,\n    applyTransforms = require('./_path.js').applyTransforms,\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    roundData,\n    precision,\n    error,\n    arcThreshold,\n    arcTolerance,\n    hasMarkerMid;\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see http://www.w3.org/TR/SVG/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\n\nexports.fn = function (item, params) {\n  if (item.isElem(pathElems) && item.hasAttr('d')) {\n    precision = params.floatPrecision;\n    error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;\n    roundData = precision > 0 && precision < 20 ? strongRound : round;\n\n    if (params.makeArcs) {\n      arcThreshold = params.makeArcs.threshold;\n      arcTolerance = params.makeArcs.tolerance;\n    }\n\n    hasMarkerMid = item.hasAttr('marker-mid');\n    var data = path2js(item); // TODO: get rid of functions returns\n\n    if (data.length) {\n      convertToRelative(data);\n\n      if (params.applyTransforms) {\n        data = applyTransforms(item, data, params);\n      }\n\n      data = filters(data, params);\n\n      if (params.utilizeAbsolute) {\n        data = convertToMixed(data, params);\n      }\n\n      js2path(item, data, params);\n    }\n  }\n};\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nfunction convertToRelative(path) {\n  var point = [0, 0],\n      subpathPoint = [0, 0],\n      baseItem;\n  path.forEach(function (item, index) {\n    var instruction = item.instruction,\n        data = item.data; // data !== !z\n\n    if (data) {\n      // already relative\n      // recalculate current point\n      if ('mcslqta'.indexOf(instruction) > -1) {\n        point[0] += data[data.length - 2];\n        point[1] += data[data.length - 1];\n\n        if (instruction === 'm') {\n          subpathPoint[0] = point[0];\n          subpathPoint[1] = point[1];\n          baseItem = item;\n        }\n      } else if (instruction === 'h') {\n        point[0] += data[0];\n      } else if (instruction === 'v') {\n        point[1] += data[0];\n      } // convert absolute path data coordinates to relative\n      // if \"M\" was not transformed from \"m\"\n      // M → m\n\n\n      if (instruction === 'M') {\n        if (index > 0) instruction = 'm';\n        data[0] -= point[0];\n        data[1] -= point[1];\n        subpathPoint[0] = point[0] += data[0];\n        subpathPoint[1] = point[1] += data[1];\n        baseItem = item;\n      } // L → l\n      // T → t\n      else if ('LT'.indexOf(instruction) > -1) {\n          instruction = instruction.toLowerCase(); // x y\n          // 0 1\n\n          data[0] -= point[0];\n          data[1] -= point[1];\n          point[0] += data[0];\n          point[1] += data[1]; // C → c\n        } else if (instruction === 'C') {\n          instruction = 'c'; // x1 y1 x2 y2 x y\n          // 0  1  2  3  4 5\n\n          data[0] -= point[0];\n          data[1] -= point[1];\n          data[2] -= point[0];\n          data[3] -= point[1];\n          data[4] -= point[0];\n          data[5] -= point[1];\n          point[0] += data[4];\n          point[1] += data[5]; // S → s\n          // Q → q\n        } else if ('SQ'.indexOf(instruction) > -1) {\n          instruction = instruction.toLowerCase(); // x1 y1 x y\n          // 0  1  2 3\n\n          data[0] -= point[0];\n          data[1] -= point[1];\n          data[2] -= point[0];\n          data[3] -= point[1];\n          point[0] += data[2];\n          point[1] += data[3]; // A → a\n        } else if (instruction === 'A') {\n          instruction = 'a'; // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n          // 0  1  2               3              4          5 6\n\n          data[5] -= point[0];\n          data[6] -= point[1];\n          point[0] += data[5];\n          point[1] += data[6]; // H → h\n        } else if (instruction === 'H') {\n          instruction = 'h';\n          data[0] -= point[0];\n          point[0] += data[0]; // V → v\n        } else if (instruction === 'V') {\n          instruction = 'v';\n          data[0] -= point[1];\n          point[1] += data[0];\n        }\n\n      item.instruction = instruction;\n      item.data = data; // store absolute coordinates for later use\n\n      item.coords = point.slice(-2);\n    } // !data === z, reset current point\n    else if (instruction == 'z') {\n        if (baseItem) {\n          item.coords = baseItem.coords;\n        }\n\n        point[0] = subpathPoint[0];\n        point[1] = subpathPoint[1];\n      }\n\n    item.base = index > 0 ? path[index - 1].coords : [0, 0];\n  });\n  return path;\n}\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nfunction filters(path, params) {\n  var stringify = data2Path.bind(null, params),\n      relSubpoint = [0, 0],\n      pathBase = [0, 0],\n      prev = {};\n  path = path.filter(function (item, index, path) {\n    var instruction = item.instruction,\n        data = item.data,\n        next = path[index + 1];\n\n    if (data) {\n      var sdata = data,\n          circle;\n\n      if (instruction === 's') {\n        sdata = [0, 0].concat(data);\n\n        if ('cs'.indexOf(prev.instruction) > -1) {\n          var pdata = prev.data,\n              n = pdata.length; // (-x, -y) of the prev tangent point relative to the current point\n\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      } // convert curves to arcs if possible\n\n\n      if (params.makeArcs && (instruction == 'c' || instruction == 's') && isConvex(sdata) && (circle = findCircle(sdata))) {\n        var r = roundData([circle.radius])[0],\n            angle = findArcAngle(sdata, circle),\n            sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n            arc = {\n          instruction: 'a',\n          data: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n          coords: item.coords.slice(),\n          base: item.base\n        },\n            output = [arc],\n            // relative coordinates to adjust the found circle\n        relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],\n            relCircle = {\n          center: relCenter,\n          radius: circle.radius\n        },\n            arcCurves = [item],\n            hasPrev = 0,\n            suffix = '',\n            nextLonghand;\n\n        if (prev.instruction == 'c' && isConvex(prev.data) && isArcPrev(prev.data, circle) || prev.instruction == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)) {\n          arcCurves.unshift(prev);\n          arc.base = prev.base;\n          arc.data[5] = arc.coords[0] - arc.base[0];\n          arc.data[6] = arc.coords[1] - arc.base[1];\n          var prevData = prev.instruction == 'a' ? prev.sdata : prev.data;\n          angle += findArcAngle(prevData, {\n            center: [prevData[4] + relCenter[0], prevData[5] + relCenter[1]],\n            radius: circle.radius\n          });\n          if (angle > Math.PI) arc.data[3] = 1;\n          hasPrev = 1;\n        } // check if next curves are fitting the arc\n\n\n        for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.instruction);) {\n          var nextData = next.data;\n\n          if (next.instruction == 's') {\n            nextLonghand = makeLonghand({\n              instruction: 's',\n              data: next.data.slice()\n            }, path[j - 1].data);\n            nextData = nextLonghand.data;\n            nextLonghand.data = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n\n            if (angle > Math.PI) arc.data[3] = 1;\n            arcCurves.push(next);\n\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              arc.coords = next.coords;\n              arc.data[5] = arc.coords[0] - arc.base[0];\n              arc.data[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.data[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.data[6] = 2 * (relCircle.center[1] - nextData[5]);\n              arc.coords = [arc.base[0] + arc.data[5], arc.base[1] + arc.data[6]];\n              arc = {\n                instruction: 'a',\n                data: [r, r, 0, 0, sweep, next.coords[0] - arc.coords[0], next.coords[1] - arc.coords[1]],\n                coords: next.coords,\n                base: arc.coords\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].instruction == 's') {\n            makeLonghand(path[j], path[j - 1].data);\n          }\n\n          if (hasPrev) {\n            var prevArc = output.shift();\n            roundData(prevArc.data);\n            relSubpoint[0] += prevArc.data[5] - prev.data[prev.data.length - 2];\n            relSubpoint[1] += prevArc.data[6] - prev.data[prev.data.length - 1];\n            prev.instruction = 'a';\n            prev.data = prevArc.data;\n            item.base = prev.coords = prevArc.coords;\n          }\n\n          arc = output.shift();\n\n          if (arcCurves.length == 1) {\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(path, [index + 1, arcCurves.length - 1 - hasPrev].concat(output));\n          }\n\n          if (!arc) return false;\n          instruction = 'a';\n          data = arc.data;\n          item.coords = arc.coords;\n        }\n      } // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n\n\n      if (precision !== false) {\n        if ('mltqsc'.indexOf(instruction) > -1) {\n          for (var i = data.length; i--;) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (instruction == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (instruction == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (instruction == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n\n        roundData(data);\n        if (instruction == 'h') relSubpoint[0] += data[0];else if (instruction == 'v') relSubpoint[1] += data[0];else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (instruction.toLowerCase() == 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      } // convert straight curves into lines segments\n\n\n      if (params.straightCurves) {\n        if (instruction === 'c' && isCurveStraightLine(data) || instruction === 's' && isCurveStraightLine(sdata)) {\n          if (next && next.instruction == 's') makeLonghand(next, data); // fix up next curve\n\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 'q' && isCurveStraightLine(data)) {\n          if (next && next.instruction == 't') makeLonghand(next, data); // fix up next curve\n\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 't' && prev.instruction !== 'q' && prev.instruction !== 't') {\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 'a' && (data[0] === 0 || data[1] === 0)) {\n          instruction = 'l';\n          data = data.slice(-2);\n        }\n      } // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n\n\n      if (params.lineShorthands && instruction === 'l') {\n        if (data[1] === 0) {\n          instruction = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          instruction = 'v';\n          data.shift();\n        }\n      } // collapse repeated commands\n      // h 20 h 30 -> h 50\n\n\n      if (params.collapseRepeated && !hasMarkerMid && 'mhv'.indexOf(instruction) > -1 && prev.instruction && instruction == prev.instruction.toLowerCase() && (instruction != 'h' && instruction != 'v' || prev.data[0] >= 0 == item.data[0] >= 0)) {\n        prev.data[0] += data[0];\n\n        if (instruction != 'h' && instruction != 'v') {\n          prev.data[1] += data[1];\n        }\n\n        prev.coords = item.coords;\n        path[index] = prev;\n        return false;\n      } // convert curves into smooth shorthands\n\n\n      if (params.curveSmoothShorthands && prev.instruction) {\n        // curveto\n        if (instruction === 'c') {\n          // c + c → c + s\n          if (prev.instruction === 'c' && data[0] === -(prev.data[2] - prev.data[4]) && data[1] === -(prev.data[3] - prev.data[5])) {\n            instruction = 's';\n            data = data.slice(2);\n          } // s + c → s + s\n          else if (prev.instruction === 's' && data[0] === -(prev.data[0] - prev.data[2]) && data[1] === -(prev.data[1] - prev.data[3])) {\n              instruction = 's';\n              data = data.slice(2);\n            } // [^cs] + c → [^cs] + s\n            else if ('cs'.indexOf(prev.instruction) === -1 && data[0] === 0 && data[1] === 0) {\n                instruction = 's';\n                data = data.slice(2);\n              }\n        } // quadratic Bézier curveto\n        else if (instruction === 'q') {\n            // q + q → q + t\n            if (prev.instruction === 'q' && data[0] === prev.data[2] - prev.data[0] && data[1] === prev.data[3] - prev.data[1]) {\n              instruction = 't';\n              data = data.slice(2);\n            } // t + q → t + t\n            else if (prev.instruction === 't' && data[2] === prev.data[0] && data[3] === prev.data[1]) {\n                instruction = 't';\n                data = data.slice(2);\n              }\n          }\n      } // remove useless non-first path segments\n\n\n      if (params.removeUseless) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if ('lhvqtcs'.indexOf(instruction) > -1 && data.every(function (i) {\n          return i === 0;\n        })) {\n          path[index] = prev;\n          return false;\n        } // a 25,25 -30 0,1 0,0\n\n\n        if (instruction === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.instruction = instruction;\n      item.data = data;\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.instruction == 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n  return path;\n}\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n\n    if (!item.data) {\n      prev = item;\n      return true;\n    }\n\n    var instruction = item.instruction,\n        data = item.data,\n        adata = data && data.slice(0);\n\n    if ('mltqsc'.indexOf(instruction) > -1) {\n      for (var i = adata.length; i--;) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (instruction == 'h') {\n      adata[0] += item.base[0];\n    } else if (instruction == 'v') {\n      adata[0] += item.base[1];\n    } else if (instruction == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n    var absoluteDataStr = cleanupOutData(adata, params),\n        relativeDataStr = cleanupOutData(data, params); // Convert to absolute coordinates if it's shorter.\n    // v-20 -> V0\n    // Don't convert if it fits following previous instruction.\n    // l20 30-10-50 instead of l20 30L20 30\n\n    if (absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && instruction == prev.instruction && prev.instruction.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || /^0\\./.test(data[0]) && prev.data[prev.data.length - 1] % 1))) {\n      item.instruction = instruction.toUpperCase();\n      item.data = adata;\n    }\n\n    prev = item;\n    return true;\n  });\n  return path;\n}\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction isConvex(data) {\n  var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);\n  return center && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];\n}\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\n\n\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3],\n      // y1 - y2\n  b1 = coords[2] - coords[0],\n      // x2 - x1\n  c1 = coords[0] * coords[3] - coords[2] * coords[1],\n      // x1 * y2 - x2 * y1\n  // Next line equation parameters\n  a2 = coords[5] - coords[7],\n      // y1 - y2\n  b2 = coords[6] - coords[4],\n      // x2 - x1\n  c2 = coords[4] * coords[7] - coords[5] * coords[6],\n      // x1 * y2 - x2 * y1\n  denom = a1 * b2 - a2 * b1;\n  if (!denom) return; // parallel lines havn't an intersection\n\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n\n  if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {\n    return cross;\n  }\n}\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0;) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n}\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction round(data) {\n  for (var i = data.length; i-- > 0;) {\n    data[i] = Math.round(data[i]);\n  }\n\n  return data;\n}\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n      a = -data[i + 1],\n      // y1 − y2 (y1 = 0)\n  b = data[i],\n      // x2 − x1 (x1 = 0)\n  d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error) return false;\n  }\n\n  return true;\n}\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\n\nfunction makeLonghand(item, data) {\n  switch (item.instruction) {\n    case 's':\n      item.instruction = 'c';\n      break;\n\n    case 't':\n      item.instruction = 'q';\n      break;\n  }\n\n  item.data.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);\n  return item;\n}\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\n\nfunction getDistance(point1, point2) {\n  return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));\n}\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n      cubT = sqrT * t,\n      mt = 1 - t,\n      sqrMt = mt * mt;\n  return [3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4], 3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]];\n}\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n      m1 = [midPoint[0] / 2, midPoint[1] / 2],\n      m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n      center = getIntersection([m1[0], m1[1], m1[0] + m1[1], m1[1] - m1[0], m2[0], m2[1], m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])]),\n      radius = center && getDistance([0, 0], center),\n      tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);\n  if (center && [1 / 4, 3 / 4].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;\n  })) return {\n    center: center,\n    radius: radius\n  };\n}\n/**\n * Checks if a curve fits the given circe.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;\n  });\n}\n/**\n * Checks if a previos curve fits the given circe.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius\n  });\n}\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n      y1 = -relCircle.center[1],\n      x2 = curve[4] - relCircle.center[0],\n      y2 = curve[5] - relCircle.center[1];\n  return Math.acos((x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)));\n}\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    return pathString += item.instruction + (item.data ? cleanupOutData(roundData(item.data.slice()), params) : '');\n  }, '');\n}","map":null,"metadata":{},"sourceType":"script"}