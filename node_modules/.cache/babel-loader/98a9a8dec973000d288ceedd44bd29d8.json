{"ast":null,"code":"'use strict';\n/*\n * Thanks to http://fontello.com project for sponsoring this plugin\n */\n\nexports.type = 'full';\nexports.active = false;\nexports.description = 'performs a set of operations on SVG with one path inside (disabled by default)';\nexports.params = {\n  // width and height to resize SVG and rescale inner Path\n  width: false,\n  height: false,\n  // scale inner Path without resizing SVG\n  scale: false,\n  // shiftX/Y inner Path\n  shiftX: false,\n  shiftY: false,\n  // crop SVG width along the real width of inner Path\n  hcrop: false,\n  // vertical center inner Path inside SVG height\n  vcenter: false,\n  // stringify params\n  floatPrecision: 3,\n  leadingZero: true,\n  negativeExtraSpace: true\n};\n\nvar _path = require('./_path.js'),\n    relative2absolute = _path.relative2absolute,\n    computeCubicBoundingBox = _path.computeCubicBoundingBox,\n    computeQuadraticBoundingBox = _path.computeQuadraticBoundingBox,\n    applyTransforms = _path.applyTransforms,\n    js2path = _path.js2path,\n    path2js = _path.path2js,\n    EXTEND = require('whet.extend');\n\nexports.fn = function (data, params) {\n  data.content.forEach(function (item) {\n    // only for SVG with one Path inside\n    if (item.isElem('svg') && item.content.length === 1 && item.content[0].isElem('path')) {\n      var svgElem = item,\n          pathElem = svgElem.content[0],\n          // get absoluted Path data\n      path = relative2absolute(EXTEND(true, [], path2js(pathElem))),\n          xs = [],\n          ys = [],\n          cubicСontrolPoint = [0, 0],\n          quadraticСontrolPoint = [0, 0],\n          lastPoint = [0, 0],\n          cubicBoundingBox,\n          quadraticBoundingBox,\n          i,\n          segment;\n      path.forEach(function (pathItem) {\n        // ML\n        if ('ML'.indexOf(pathItem.instruction) > -1) {\n          for (i = 0; i < pathItem.data.length; i++) {\n            if (i % 2 === 0) {\n              xs.push(pathItem.data[i]);\n            } else {\n              ys.push(pathItem.data[i]);\n            }\n          }\n\n          lastPoint = cubicСontrolPoint = quadraticСontrolPoint = pathItem.data.slice(-2); // H\n        } else if (pathItem.instruction === 'H') {\n          pathItem.data.forEach(function (d) {\n            xs.push(d);\n          });\n          lastPoint[0] = cubicСontrolPoint[0] = quadraticСontrolPoint[0] = pathItem.data[pathItem.data.length - 2]; // V\n        } else if (pathItem.instruction === 'V') {\n          pathItem.data.forEach(function (d) {\n            ys.push(d);\n          });\n          lastPoint[1] = cubicСontrolPoint[1] = quadraticСontrolPoint[1] = pathItem.data[pathItem.data.length - 1]; // C\n        } else if (pathItem.instruction === 'C') {\n          for (i = 0; i < pathItem.data.length; i += 6) {\n            segment = pathItem.data.slice(i, i + 6);\n            cubicBoundingBox = computeCubicBoundingBox.apply(this, lastPoint.concat(segment));\n            xs.push(cubicBoundingBox.minx);\n            xs.push(cubicBoundingBox.maxx);\n            ys.push(cubicBoundingBox.miny);\n            ys.push(cubicBoundingBox.maxy); // reflected control point for the next possible S\n\n            cubicСontrolPoint = [2 * segment[4] - segment[2], 2 * segment[5] - segment[3]];\n            lastPoint = segment.slice(-2);\n          } // S\n\n        } else if (pathItem.instruction === 'S') {\n          for (i = 0; i < pathItem.data.length; i += 4) {\n            segment = pathItem.data.slice(i, i + 4);\n            cubicBoundingBox = computeCubicBoundingBox.apply(this, lastPoint.concat(cubicСontrolPoint).concat(segment));\n            xs.push(cubicBoundingBox.minx);\n            xs.push(cubicBoundingBox.maxx);\n            ys.push(cubicBoundingBox.miny);\n            ys.push(cubicBoundingBox.maxy); // reflected control point for the next possible S\n\n            cubicСontrolPoint = [2 * segment[2] - cubicСontrolPoint[0], 2 * segment[3] - cubicСontrolPoint[1]];\n            lastPoint = segment.slice(-2);\n          } // Q\n\n        } else if (pathItem.instruction === 'Q') {\n          for (i = 0; i < pathItem.data.length; i += 4) {\n            segment = pathItem.data.slice(i, i + 4);\n            quadraticBoundingBox = computeQuadraticBoundingBox.apply(this, lastPoint.concat(segment));\n            xs.push(quadraticBoundingBox.minx);\n            xs.push(quadraticBoundingBox.maxx);\n            ys.push(quadraticBoundingBox.miny);\n            ys.push(quadraticBoundingBox.maxy); // reflected control point for the next possible T\n\n            quadraticСontrolPoint = [2 * segment[2] - segment[0], 2 * segment[3] - segment[1]];\n            lastPoint = segment.slice(-2);\n          } // S\n\n        } else if (pathItem.instruction === 'T') {\n          for (i = 0; i < pathItem.data.length; i += 2) {\n            segment = pathItem.data.slice(i, i + 2);\n            quadraticBoundingBox = computeQuadraticBoundingBox.apply(this, lastPoint.concat(quadraticСontrolPoint).concat(segment));\n            xs.push(quadraticBoundingBox.minx);\n            xs.push(quadraticBoundingBox.maxx);\n            ys.push(quadraticBoundingBox.miny);\n            ys.push(quadraticBoundingBox.maxy); // reflected control point for the next possible T\n\n            quadraticСontrolPoint = [2 * segment[0] - quadraticСontrolPoint[0], 2 * segment[1] - quadraticСontrolPoint[1]];\n            lastPoint = segment.slice(-2);\n          }\n        }\n      });\n      var xmin = Math.min.apply(this, xs).toFixed(params.floatPrecision),\n          xmax = Math.max.apply(this, xs).toFixed(params.floatPrecision),\n          ymin = Math.min.apply(this, ys).toFixed(params.floatPrecision),\n          ymax = Math.max.apply(this, ys).toFixed(params.floatPrecision),\n          svgWidth = +svgElem.attr('width').value,\n          svgHeight = +svgElem.attr('height').value,\n          realWidth = Math.round(xmax - xmin),\n          realHeight = Math.round(ymax - ymin),\n          transform = '',\n          scale; // width & height\n\n      if (params.width && params.height) {\n        scale = Math.min(params.width / svgWidth, params.height / svgHeight);\n        realWidth = realWidth * scale;\n        realHeight = realHeight * scale;\n        svgWidth = svgElem.attr('width').value = params.width;\n        svgHeight = svgElem.attr('height').value = params.height;\n        transform += ' scale(' + scale + ')'; // width\n      } else if (params.width && !params.height) {\n        scale = params.width / svgWidth;\n        realWidth = realWidth * scale;\n        realHeight = realHeight * scale;\n        svgWidth = svgElem.attr('width').value = params.width;\n        svgHeight = svgElem.attr('height').value = svgHeight * scale;\n        transform += ' scale(' + scale + ')'; // height\n      } else if (params.height && !params.width) {\n        scale = params.height / svgHeight;\n        realWidth = realWidth * scale;\n        realHeight = realHeight * scale;\n        svgWidth = svgElem.attr('width').value = svgWidth * scale;\n        svgHeight = svgElem.attr('height').value = params.height;\n        transform += ' scale(' + scale + ')';\n      } // shiftX\n\n\n      if (params.shiftX) {\n        transform += ' translate(' + realWidth * params.shiftX + ', 0)';\n      } // shiftY\n\n\n      if (params.shiftY) {\n        transform += ' translate(0, ' + realHeight * params.shiftY + ')';\n      } // scale\n\n\n      if (params.scale) {\n        scale = params.scale;\n        var shiftX = svgWidth / 2,\n            shiftY = svgHeight / 2;\n        realWidth = realWidth * scale;\n        realHeight = realHeight * scale;\n\n        if (params.shiftX || params.shiftY) {\n          transform += ' scale(' + scale + ')';\n        } else {\n          transform += ' translate(' + shiftX + ' ' + shiftY + ') scale(' + scale + ') translate(-' + shiftX + ' -' + shiftY + ')';\n        }\n      } // hcrop\n\n\n      if (params.hcrop) {\n        transform += ' translate(' + -xmin + ' 0)';\n        svgElem.attr('width').value = realWidth;\n      } // vcenter\n\n\n      if (params.vcenter) {\n        transform += ' translate(0 ' + ((svgHeight - realHeight) / 2 - ymin) + ')';\n      }\n\n      if (transform) {\n        pathElem.addAttr({\n          name: 'transform',\n          prefix: '',\n          local: 'transform',\n          value: transform\n        });\n        path = applyTransforms(pathElem, pathElem.pathJS, true, params.floatPrecision); // transformed data rounding\n\n        path.forEach(function (pathItem) {\n          if (pathItem.data) {\n            pathItem.data = pathItem.data.map(function (num) {\n              return +num.toFixed(params.floatPrecision);\n            });\n          }\n        }); // save new\n\n        js2path(pathElem, path, params);\n      }\n    }\n  });\n  return data;\n};","map":null,"metadata":{},"sourceType":"script"}