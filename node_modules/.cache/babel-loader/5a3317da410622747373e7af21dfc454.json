{"ast":null,"code":"'use strict';\n\nexports.type = 'perItem';\nexports.active = true;\nexports.description = 'collapses multiple transformations and optimizes it';\nexports.params = {\n  convertToShorts: true,\n  // degPrecision: 3, // transformPrecision (or matrix precision) - 2 by default\n  floatPrecision: 3,\n  transformPrecision: 5,\n  matrixToTransform: true,\n  shortTranslate: true,\n  shortScale: true,\n  shortRotate: true,\n  removeUseless: true,\n  collapseIntoOne: true,\n  leadingZero: true,\n  negativeExtraSpace: false\n};\n\nvar cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    EXTEND = require('whet.extend'),\n    transform2js = require('./_transforms.js').transform2js,\n    transformsMultiply = require('./_transforms.js').transformsMultiply,\n    matrixToTransform = require('./_transforms.js').matrixToTransform,\n    degRound,\n    floatRound,\n    transformRound;\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\n\nexports.fn = function (item, params) {\n  if (item.elem) {\n    // transform\n    if (item.hasAttr('transform')) {\n      convertTransform(item, 'transform', params);\n    } // gradientTransform\n\n\n    if (item.hasAttr('gradientTransform')) {\n      convertTransform(item, 'gradientTransform', params);\n    } // patternTransform\n\n\n    if (item.hasAttr('patternTransform')) {\n      convertTransform(item, 'patternTransform', params);\n    }\n  }\n};\n/**\n * Main function.\n *\n * @param {Object} item input item\n * @param {String} attrName attribute name\n * @param {Object} params plugin params\n */\n\n\nfunction convertTransform(item, attrName, params) {\n  var data = transform2js(item.attr(attrName).value);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach(roundTransform);\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attr(attrName).value = js2transform(data, params);\n  } else {\n    item.removeAttr(attrName);\n  }\n}\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @param {Array} transforms input array\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\n\nfunction definePrecision(data, params) {\n  /* jshint validthis: true */\n  var matrixData = data.reduce(getMatrixData, []),\n      significantDigits = params.transformPrecision; // Clone params so it don't affect other elements transformations.\n\n  params = EXTEND({}, params); // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n\n  if (matrixData.length) {\n    params.transformPrecision = Math.min(params.transformPrecision, Math.max.apply(Math, matrixData.map(floatDigits)) || params.transformPrecision);\n    significantDigits = Math.max.apply(Math, matrixData.map(function (n) {\n      return String(n).replace(/\\D+/g, '').length; // Number of digits in a number. 123.45 → 5\n    }));\n  } // No sense in angle precision more then number of significant digits in matrix.\n\n\n  if (!('degPrecision' in params)) {\n    params.degPrecision = Math.max(0, Math.min(params.floatPrecision, significantDigits - 2));\n  }\n\n  floatRound = params.floatPrecision >= 1 && params.floatPrecision < 20 ? smartRound.bind(this, params.floatPrecision) : round;\n  degRound = params.degPrecision >= 1 && params.floatPrecision < 20 ? smartRound.bind(this, params.degPrecision) : round;\n  transformRound = params.transformPrecision >= 1 && params.floatPrecision < 20 ? smartRound.bind(this, params.transformPrecision) : round;\n  return params;\n}\n/**\n * Gathers four first matrix parameters.\n *\n * @param {Array} a array of data\n * @param {Object} transform\n * @return {Array} output array\n */\n\n\nfunction getMatrixData(a, b) {\n  return b.name == 'matrix' ? a.concat(b.data.slice(0, 4)) : a;\n}\n/**\n * Returns number of digits after the point. 0.125 → 3\n */\n\n\nfunction floatDigits(n) {\n  return (n = String(n)).slice(n.indexOf('.')).length - 1;\n}\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @param {Array} transforms input array\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\n\nfunction convertToShorts(transforms, params) {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i]; // convert matrix to the short aliases\n\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n\n      if (decomposed != transform && js2transform(decomposed, params).length <= js2transform([transform], params).length) {\n        transforms.splice.apply(transforms, [i, 1].concat(decomposed));\n      }\n\n      transform = transforms[i];\n    } // fixed-point numbers\n    // 12.754997 → 12.755\n\n\n    roundTransform(transform); // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n\n    if (params.shortTranslate && transform.name === 'translate' && transform.data.length === 2 && !transform.data[1]) {\n      transform.data.pop();\n    } // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n\n\n    if (params.shortScale && transform.name === 'scale' && transform.data.length === 2 && transform.data[0] === transform.data[1]) {\n      transform.data.pop();\n    } // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n\n\n    if (params.shortRotate && transforms[i - 2] && transforms[i - 2].name === 'translate' && transforms[i - 1].name === 'rotate' && transforms[i].name === 'translate' && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [transforms[i - 1].data[0], transforms[i - 2].data[0], transforms[i - 2].data[1]]\n      }); // splice compensation\n\n      i -= 2;\n      transform = transforms[i];\n    }\n  }\n\n  return transforms;\n}\n/**\n * Remove useless transforms.\n *\n * @param {Array} transforms input array\n * @return {Array} output array\n */\n\n\nfunction removeUseless(transforms) {\n  return transforms.filter(function (transform) {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == 'rotate') && !transform.data[0] || // translate(0, 0)\n    transform.name == 'translate' && !transform.data[0] && !transform.data[1] || // scale(1)\n    transform.name == 'scale' && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || // matrix(1 0 0 1 0 0)\n    transform.name == 'matrix' && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {\n      return false;\n    }\n\n    return true;\n  });\n}\n/**\n * Convert transforms JS representation to string.\n *\n * @param {Array} transformJS JS representation array\n * @param {Object} params plugin params\n * @return {String} output string\n */\n\n\nfunction js2transform(transformJS, params) {\n  var transformString = ''; // collect output value string\n\n  transformJS.forEach(function (transform) {\n    roundTransform(transform);\n    transformString += (transformString && ' ') + transform.name + '(' + cleanupOutData(transform.data, params) + ')';\n  });\n  return transformString;\n}\n\nfunction roundTransform(transform) {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data);\n      break;\n\n    case 'rotate':\n      transform.data = degRound(transform.data.slice(0, 1)).concat(floatRound(transform.data.slice(1)));\n      break;\n\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data);\n      break;\n\n    case 'scale':\n      transform.data = transformRound(transform.data);\n      break;\n\n    case 'matrix':\n      transform.data = transformRound(transform.data.slice(0, 4)).concat(floatRound(transform.data.slice(4)));\n      break;\n  }\n\n  return transform;\n}\n/**\n * Rounds numbers in array.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction round(data) {\n  return data.map(Math.round);\n}\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @param {Number} fixed number of decimals\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction smartRound(precision, data) {\n  for (var i = data.length, tolerance = +Math.pow(.1, precision).toFixed(precision); i--;) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n}","map":null,"metadata":{},"sourceType":"script"}