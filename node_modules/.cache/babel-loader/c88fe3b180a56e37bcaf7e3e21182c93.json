{"ast":null,"code":"'use strict';\n\nvar EXTEND = require('whet.extend');\n\nvar JSAPI = module.exports = function (data, parentNode) {\n  EXTEND(this, data);\n\n  if (parentNode) {\n    Object.defineProperty(this, 'parentNode', {\n      writable: true,\n      value: parentNode\n    });\n  }\n};\n/**\n * Perform a deep clone of this node.\n *\n * @return {Object} element\n */\n\n\nJSAPI.prototype.clone = function () {\n  var node = this;\n  var nodeData = {};\n  Object.keys(node).forEach(function (key) {\n    if (key !== 'content') {\n      nodeData[key] = node[key];\n    }\n  }); // Deep-clone node data\n  // This is still faster than using EXTEND(trueâ€¦)\n\n  nodeData = JSON.parse(JSON.stringify(nodeData)); // parentNode gets set to a proper object by the parent clone,\n  // but it needs to be true/false now to do the right thing\n  // in the constructor.\n\n  var clonedNode = new JSAPI(nodeData, !!node.parentNode);\n\n  if (node.content) {\n    clonedNode.content = node.content.map(function (childNode) {\n      var clonedChild = childNode.clone();\n      clonedChild.parentNode = clonedNode;\n      return clonedChild;\n    });\n  }\n\n  return clonedNode;\n};\n/**\n * Determine if item is an element\n * (any, with a specific name or in a names array).\n *\n * @param {String|Array} [param] element name or names arrays\n * @return {Boolean}\n */\n\n\nJSAPI.prototype.isElem = function (param) {\n  if (!param) return !!this.elem;\n  if (Array.isArray(param)) return !!this.elem && param.indexOf(this.elem) > -1;\n  return !!this.elem && this.elem === param;\n};\n/**\n * Renames an element\n *\n * @param {String} name new element name\n * @return {Object} element\n */\n\n\nJSAPI.prototype.renameElem = function (name) {\n  if (name && typeof name === 'string') this.elem = this.local = name;\n  return this;\n};\n/**\n * Determine if element is empty.\n *\n * @return {Boolean}\n */\n\n\nJSAPI.prototype.isEmpty = function () {\n  return !this.content || !this.content.length;\n};\n/**\n * Changes content by removing elements and/or adding new elements.\n *\n * @param {Number} start Index at which to start changing the content.\n * @param {Number} n Number of elements to remove.\n * @param {Array|Object} [insertion] Elements to add to the content.\n * @return {Array} Removed elements.\n */\n\n\nJSAPI.prototype.spliceContent = function (start, n, insertion) {\n  if (arguments.length < 2) return [];\n  if (!Array.isArray(insertion)) insertion = Array.apply(null, arguments).slice(2);\n  insertion.forEach(function (inner) {\n    inner.parentNode = this;\n  }, this);\n  return this.content.splice.apply(this.content, [start, n].concat(insertion));\n};\n/**\n * Determine if element has an attribute\n * (any, or by name or by name + value).\n *\n * @param {String} [name] attribute name\n * @param {String} [val] attribute value (will be toString()'ed)\n * @return {Boolean}\n */\n\n\nJSAPI.prototype.hasAttr = function (name, val) {\n  if (!this.attrs || !Object.keys(this.attrs).length) return false;\n  if (!arguments.length) return !!this.attrs;\n  if (val !== undefined) return !!this.attrs[name] && this.attrs[name].value === val.toString();\n  return !!this.attrs[name];\n};\n/**\n * Determine if element has an attribute by local name\n * (any, or by name or by name + value).\n *\n * @param {String} [localName] local attribute name\n * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)\n * @return {Boolean}\n */\n\n\nJSAPI.prototype.hasAttrLocal = function (localName, val) {\n  if (!this.attrs || !Object.keys(this.attrs).length) return false;\n  if (!arguments.length) return !!this.attrs;\n  var callback;\n\n  switch (val != null && val.constructor && val.constructor.name) {\n    case 'Number': // same as String\n\n    case 'String':\n      callback = stringValueTest;\n      break;\n\n    case 'RegExp':\n      callback = regexpValueTest;\n      break;\n\n    case 'Function':\n      callback = funcValueTest;\n      break;\n\n    default:\n      callback = nameTest;\n  }\n\n  return this.someAttr(callback);\n\n  function nameTest(attr) {\n    return attr.local === localName;\n  }\n\n  function stringValueTest(attr) {\n    return attr.local === localName && val == attr.value;\n  }\n\n  function regexpValueTest(attr) {\n    return attr.local === localName && val.test(attr.value);\n  }\n\n  function funcValueTest(attr) {\n    return attr.local === localName && val(attr.value);\n  }\n};\n/**\n * Get a specific attribute from an element\n * (by name or name + value).\n *\n * @param {String} name attribute name\n * @param {String} [val] attribute value (will be toString()'ed)\n * @return {Object|Undefined}\n */\n\n\nJSAPI.prototype.attr = function (name, val) {\n  if (!this.hasAttr() || !arguments.length) return undefined;\n  if (val !== undefined) return this.hasAttr(name, val) ? this.attrs[name] : undefined;\n  return this.attrs[name];\n};\n/**\n * Get computed attribute value from an element\n *\n * @param {String} name attribute name\n * @return {Object|Undefined}\n */\n\n\nJSAPI.prototype.computedAttr = function (name, val) {\n  /* jshint eqnull: true */\n  if (!arguments.length) return;\n\n  for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attr(name).value); elem = elem.parentNode) {\n    ;\n  }\n\n  if (val != null) {\n    return elem ? elem.hasAttr(name, val) : false;\n  } else if (elem && elem.hasAttr(name)) {\n    return elem.attrs[name].value;\n  }\n};\n/**\n * Remove a specific attribute.\n *\n * @param {String|Array} name attribute name\n * @param {String} [val] attribute value\n * @return {Boolean}\n */\n\n\nJSAPI.prototype.removeAttr = function (name, val, recursive) {\n  if (!arguments.length) return false;\n  if (Array.isArray(name)) name.forEach(this.removeAttr, this);\n  if (!this.hasAttr(name)) return false;\n  if (!recursive && val && this.attrs[name].value !== val) return false;\n  delete this.attrs[name];\n  if (!Object.keys(this.attrs).length) delete this.attrs;\n  return true;\n};\n/**\n * Add attribute.\n *\n * @param {Object} [attr={}] attribute object\n * @return {Object|Boolean} created attribute or false if no attr was passed in\n */\n\n\nJSAPI.prototype.addAttr = function (attr) {\n  attr = attr || {};\n  if (attr.name === undefined || attr.value === undefined || attr.prefix === undefined || attr.local === undefined) return false;\n  this.attrs = this.attrs || {};\n  this.attrs[attr.name] = attr;\n  return this.attrs[attr.name];\n};\n/**\n * Iterates over all attributes.\n *\n * @param {Function} callback callback\n * @param {Object} [context] callback context\n * @return {Boolean} false if there are no any attributes\n */\n\n\nJSAPI.prototype.eachAttr = function (callback, context) {\n  if (!this.hasAttr()) return false;\n\n  for (var name in this.attrs) {\n    callback.call(context, this.attrs[name]);\n  }\n\n  return true;\n};\n/**\n * Tests whether some attribute passes the test.\n *\n * @param {Function} callback callback\n * @param {Object} [context] callback context\n * @return {Boolean} false if there are no any attributes\n */\n\n\nJSAPI.prototype.someAttr = function (callback, context) {\n  if (!this.hasAttr()) return false;\n\n  for (var name in this.attrs) {\n    if (callback.call(context, this.attrs[name])) return true;\n  }\n\n  return false;\n};","map":null,"metadata":{},"sourceType":"script"}