{"ast":null,"code":"'use strict';\n\nvar SAX = require('sax'),\n    JSAPI = require('./jsAPI.js'),\n    entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^\\']+)'|\"([^\\\"]+)\")\\s*>/g;\n\nvar config = {\n  strict: true,\n  trim: false,\n  normalize: true,\n  lowercase: true,\n  xmlns: true,\n  position: true\n};\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @param {String} data input data\n * @param {Function} callback\n */\n\nmodule.exports = function (data, callback) {\n  var sax = SAX.parser(config.strict, config),\n      root = new JSAPI({\n    elem: '#document'\n  }),\n      current = root,\n      stack = [root],\n      textContext = null,\n      parsingError = false;\n\n  function pushToContent(content) {\n    content = new JSAPI(content, current);\n    (current.content = current.content || []).push(content);\n    return content;\n  }\n\n  sax.ondoctype = function (doctype) {\n    pushToContent({\n      doctype: doctype\n    });\n    var subsetStart = doctype.indexOf('['),\n        entityMatch;\n\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n\n      while ((entityMatch = entityDeclaration.exec(data)) != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n      }\n    }\n  };\n\n  sax.onprocessinginstruction = function (data) {\n    pushToContent({\n      processinginstruction: data\n    });\n  };\n\n  sax.oncomment = function (comment) {\n    pushToContent({\n      comment: comment.trim()\n    });\n  };\n\n  sax.oncdata = function (cdata) {\n    pushToContent({\n      cdata: cdata\n    });\n  };\n\n  sax.onopentag = function (data) {\n    var elem = {\n      elem: data.name,\n      prefix: data.prefix,\n      local: data.local\n    };\n\n    if (Object.keys(data.attributes).length) {\n      elem.attrs = {};\n\n      for (var name in data.attributes) {\n        elem.attrs[name] = {\n          name: name,\n          value: data.attributes[name].value,\n          prefix: data.attributes[name].prefix,\n          local: data.attributes[name].local\n        };\n      }\n    }\n\n    elem = pushToContent(elem);\n    current = elem; // Save info about <text> tag to prevent trimming of meaningful whitespace\n\n    if (data.name == 'text' && !data.prefix) {\n      textContext = current;\n    }\n\n    stack.push(elem);\n  };\n\n  sax.ontext = function (text) {\n    if (/\\S/.test(text) || textContext) {\n      if (!textContext) text = text.trim();\n      pushToContent({\n        text: text\n      });\n    }\n  };\n\n  sax.onclosetag = function () {\n    var last = stack.pop(); // Trim text inside <text> tag.\n\n    if (last == textContext) {\n      trim(textContext);\n      textContext = null;\n    }\n\n    current = stack[stack.length - 1];\n  };\n\n  sax.onerror = function (e) {\n    e.message = 'Error in parsing SVG: ' + e.message;\n\n    if (e.message.indexOf('Unexpected end') < 0) {\n      throw e;\n    }\n  };\n\n  sax.onend = function () {\n    if (!this.error) {\n      callback(root);\n    } else {\n      callback({\n        error: this.error.message\n      });\n    }\n  };\n\n  try {\n    sax.write(data);\n  } catch (e) {\n    callback({\n      error: e.message\n    });\n    parsingError = true;\n  }\n\n  if (!parsingError) sax.close();\n\n  function trim(elem) {\n    if (!elem.content) return elem;\n    var start = elem.content[0],\n        end = elem.content[elem.content.length - 1];\n\n    while (start && start.content && !start.text) {\n      start = start.content[0];\n    }\n\n    if (start && start.text) start.text = start.text.replace(/^\\s+/, '');\n\n    while (end && end.content && !end.text) {\n      end = end.content[end.content.length - 1];\n    }\n\n    if (end && end.text) end.text = end.text.replace(/\\s+$/, '');\n    return elem;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}