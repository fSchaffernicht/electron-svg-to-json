{"ast":null,"code":"'use strict';\n\nexports.type = 'perItemReverse';\nexports.active = true;\nexports.description = 'moves elements attributes to the existing group wrapper';\n\nvar inheritableAttrs = require('./_collections').inheritableAttrs,\n    pathElems = require('./_collections.js').pathElems;\n/**\n * Collapse content's intersected and inheritable\n * attributes to the existing group wrapper.\n *\n * @example\n * <g attr1=\"val1\">\n *     <g attr2=\"val2\">\n *         text\n *     </g>\n *     <circle attr2=\"val2\" attr3=\"val3\"/>\n * </g>\n *              â¬‡\n * <g attr1=\"val1\" attr2=\"val2\">\n *     <g>\n *         text\n *     </g>\n *    <circle attr3=\"val3\"/>\n * </g>\n *\n * @param {Object} item current iteration item\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\n\nexports.fn = function (item) {\n  if (item.isElem('g') && !item.isEmpty() && item.content.length > 1) {\n    var intersection = {},\n        hasTransform = false,\n        hasClip = item.hasAttr('clip-path') || item.hasAttr('mask'),\n        intersected = item.content.every(function (inner) {\n      if (inner.isElem() && inner.hasAttr()) {\n        // don't mess with possible styles (hack until CSS parsing is implemented)\n        if (inner.hasAttr('class')) return false;\n\n        if (!Object.keys(intersection).length) {\n          intersection = inner.attrs;\n        } else {\n          intersection = intersectInheritableAttrs(intersection, inner.attrs);\n          if (!intersection) return false;\n        }\n\n        return true;\n      }\n    }),\n        allPath = item.content.every(function (inner) {\n      return inner.isElem(pathElems);\n    });\n\n    if (intersected) {\n      item.content.forEach(function (g) {\n        for (var name in intersection) {\n          if (!allPath && !hasClip || name !== 'transform') {\n            g.removeAttr(name);\n\n            if (name === 'transform') {\n              if (!hasTransform) {\n                if (item.hasAttr('transform')) {\n                  item.attr('transform').value += ' ' + intersection[name].value;\n                } else {\n                  item.addAttr(intersection[name]);\n                }\n\n                hasTransform = true;\n              }\n            } else {\n              item.addAttr(intersection[name]);\n            }\n          }\n        }\n      });\n    }\n  }\n};\n/**\n * Intersect inheritable attributes.\n *\n * @param {Object} a first attrs object\n * @param {Object} b second attrs object\n *\n * @return {Object} intersected attrs object\n */\n\n\nfunction intersectInheritableAttrs(a, b) {\n  var c = {};\n\n  for (var n in a) {\n    if (b.hasOwnProperty(n) && inheritableAttrs.indexOf(n) > -1 && a[n].name === b[n].name && a[n].value === b[n].value && a[n].prefix === b[n].prefix && a[n].local === b[n].local) {\n      c[n] = a[n];\n    }\n  }\n\n  if (!Object.keys(c).length) return false;\n  return c;\n}","map":null,"metadata":{},"sourceType":"script"}